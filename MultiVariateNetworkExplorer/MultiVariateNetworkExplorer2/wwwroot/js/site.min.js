const toggleNetworkInput = function () {
    $("#mvn-input-section").toggleClass("active-block");
    hideAllInputForms();
}

const hideAllInputForms = function () {
    $("#mvn-input-section form.active-flex").removeClass('active-flex');
}

const openNetworkInputForm = function (formId) {
    toggleNetworkInput();
    $("#" + formId).addClass("active-flex");
}



const addCollapsibleEventListeners = function () {
    const parameter_collapsibles = document.getElementsByClassName("collapsible-parameters-btn");

    for (const parameter_collapsible of parameter_collapsibles) {
        //for (let i = 0; i < parameter_collapsibles.length; i++) {
        parameter_collapsible.addEventListener("click", function () {
            this.classList.toggle("collapsible-parameters-btn-active");
            const content = this.nextElementSibling;

            content.style.height = content.clientHeight ? 0 : content.scrollHeight + "px";
        });
    };
}

const addFileButtonsEventListeners = function () {
    const inputs = document.getElementsByClassName('inputfile');

    for (const input of inputs) {
        const label = input.nextElementSibling;
        const labelTooltip = label.nextElementSibling;

        input.addEventListener('change', function (e) {
            let fileName = '';
            fileName = e.target.value.split('\\').pop();
            if (fileName) {
                label.innerText = fileName;
                labelTooltip.innerHTML = fileName;
                label.style.backgroundColor = "green";
            }
        });

        
        label.addEventListener('mouseover', function (e) {
            if (label.style.backgroundColor === "green") {
                labelTooltip.style.visibility = "visible";
            }
        });

        label.addEventListener('mouseout', function (e) {
            labelTooltip.style.visibility = "hidden";
        });
    }
}

const dropFileHandler = function (e) {
    e.preventDefault();
    const changeEvent = new Event("change");
    if (e.dataTransfer.items) {
        // Use DataTransferItemList interface to access the file(s)
        [...e.dataTransfer.items].forEach((item, i) => {
            // If dropped items aren't files, reject them
            if (item.kind === "file") {
                const file = item.getAsFile();
                fileName = file.name;
                if (fileName) {
                    e.target.innerHTML = fileName;
                    e.target.nextElementSibling.innerHTML = fileName;
                    e.target.previousElementSibling.files = e.dataTransfer.files;
                    e.target.style.backgroundColor = "green";
                }
            }
        });
    } else {
        // Use DataTransfer interface to access the file(s)
        [...e.dataTransfer.files].forEach((file, i) => {
            fileName = file.name;
            if (fileName) {
                e.target.innerHTML = fileName;
                e.target.nextElementSibling.innerHTML = fileName;
                e.target.previousElementSibling.files = e.dataTransfer.files;
                e.target.style.backgroundColor = "green";
            }
        });
    }
}

const dragOverFileHandler = function (e) {
    e.preventDefault();
    
}

const selectFocusIn = function (select_element) {
    select_element.style.textAlign = "left";
}

const selectFocusOut = function (select_element) {
    select_element.style.textAlign = "center";
}

const recalculateCollapsibleContentHeight = function (collapsible_content_id) {
    const content = document.getElementById(collapsible_content_id);
    content.style.height = "auto";
}

const hideConversionParameters = function (parameter_container, parameter_div_class) {
    const parameters_divs = parameter_container.querySelectorAll("." + parameter_div_class);

    for (const parameters_div of parameters_divs) {
        parameters_div.style.display = "none";

        const inputs = parameters_div.querySelectorAll("input");
        for (const input of inputs) {
            input.disabled = true;
        }
    }
}

const displayParametersElements = function (parameter_container, parameter_div_id) {
    const parameters_div = parameter_container.querySelector("#" + parameter_div_id);

    parameters_div.style.display = "grid";

    const inputs = parameters_div.querySelectorAll("input");
    for (const input of inputs) {
        input.disabled = false;
    }
}

const displayMetricParameters = function (metricSelectId) {

    const metric_select = document.getElementById(metricSelectId);

    const metric_select_value = metric_select.value;
    const parameter_container = metric_select.nextElementSibling;

    hideConversionParameters(parameter_container, "metric-parameters");
    switch (metric_select_value) {

        case "GaussKernel": {
            displayParametersElements(parameter_container, "gauss-parameters");
            break;
        }
    }

}

const displayAlgorithmParameters = function (algorithmSelectId, parameterDivSuffix) {
    const algorithm_select = document.getElementById(algorithmSelectId);
    const algorithm_parameter_id = algorithm_select.value.toLowerCase() + parameterDivSuffix;
    const parameter_container = algorithm_select.nextElementSibling;

    hideConversionParameters(parameter_container, "algorithm-parameters");
    displayParametersElements(parameter_container, algorithm_parameter_id);
    
}

const selectDropDownOption = function (dropDownId, optionValue) {
    document
        .getElementById(dropDownId)
        .querySelector(`option[value="${optionValue}"]`)
        .setAttribute("selected", "selected");

}

const prepareInputForm = function () {
    addFileButtonsEventListeners();
    addCollapsibleEventListeners();
    displayMetricParameters("InputModel_MetricName");
    displayAlgorithmParameters("InputModel_ConversionAlgorithmName", "-parameters");
    displayMetricParameters("append-metric");
    displayAlgorithmParameters("append-convert", "-parameters-append");

    const mvn_input_section = document.getElementById("mvn-input-section");
    mvn_input_section.addEventListener("click", toggleNetworkInput);
    for (const form of mvn_input_section.querySelectorAll("form")) {
        form.addEventListener('click', function (e) {
            e.stopPropagation();
        });
    }

    $("mvn-input-form").on("submit", function (e) {
        e.preventDefault();
        const isValid = validateNewNetworkForm(this);
        if (isValid) {
            $.ajax({
            type: "POST",
            contentType: 'application/x-www-form-urlencoded; charset=UTF-8',
            url: '/Home/LoadGraph',
            data: formData
            });
        }

        return isValid;

    });

    //$("#mvn-append-form").submit(function (e) {
    //    const current_graph_input = e.currentTarget.querySelector("#currentGraph");
    //    current_graph_input.value = JSON.stringify(store);
    //});

}

const isNullOrEmpty = function (string) {
    return string === null || string === "";
}

const validateNewNetworkForm = function (form) {
    let isValid = true;
    let errorMessage = "";

    const vectorFile = form.querySelector("#fileVector").value;
    if (isNullOrEmpty(vectorFile)) {
        errorMessage += "Please insert the vector file.<br>";
        isValid = false;
    }

    const separators = form.querySelector("#InputModel_Separators").value;
    if (isNullOrEmpty(separators)) {
        errorMessage += "Please enter the data separating character.<br>";
        isValid = false;
    }

    const missingValues = form.querySelector("#InputModel_MissingValues").value;
    if (isNullOrEmpty(missingValues)) {
        errorMessage += "Please enter the string which will represents missing values.<br>";
        isValid = false;
    }

    const errorParagraph = form.querySelector("#new-network-error-para");
    errorParagraph.innerHTML = errorMessage;
    
    return isValid;
}

const validateAppendNetworkForm = function (form) {
    let isValid = true;
    let errorMessage = "";

    if (graph.nodes.length <= 0) {
        errorMessage += "There is no graph to append to.<br>";
        isValid = false;
    }

    const vectorFile = form.querySelector("#fileVectorAppend").value;
    if (isNullOrEmpty(vectorFile)) {
        errorMessage += "Please insert the vector file.<br>";
        isValid = false;
    }

    const separators = form.querySelector("#separatorsAppend").value;
    if (isNullOrEmpty(separators)) {
        errorMessage += "Please enter the data separating character.<br>";
        isValid = false;
    }

    const missingValues = form.querySelector("#missingvaluesAppend").value;
    if (isNullOrEmpty(missingValues)) {
        errorMessage += "Please enter the string which will represents missing values.<br>";
        isValid = false;
    }

    const errorParagraph = form.querySelector("#append-network-error-para");
    errorParagraph.innerHTML = errorMessage;

    return isValid;
}

const switchFormPart = function (partId1, partId2) {
    document.getElementById(partId1).style.display = "none";
    document.getElementById(partId2).style.display = "block";
}

const loadDataset = function () {
    const form = document.getElementById("mvn-input-form");
    validateNewNetworkForm(form);
    const fileInput = document.getElementById("fileVector");
    const file = fileInput.files[0];
    const reader = new FileReader();

    reader.onload = function (e) {
        const text = e.target.result;

        // Here you parse the file content (CSV for example)
        const lines = text.split("\n").slice(0, 6); // preview first 5 rows

        const separator = document.getElementById("InputModel_Separators").value;
        const missingValuesString = document.getElementById("InputModel_MissingValues").value;
        const idColumnName = document.getElementById("InputModel_IdColumnName").value;
        const headers = lines[0].split(separator);

        // Auto-detect attribute types (simple example: numeric vs categorical)
        const tbody = document.querySelector("#attribute-table tbody");
        tbody.innerHTML = "";
        headers.forEach((col, idx) => {
            if (col === idColumnName) {
                return;
            }
            const sampleValues = lines.slice(1).map(l => l.split(separator)[idx]);
            const isNumeric = sampleValues.every(v => !isNaN(parseFloat(v) || v === missingValuesString));

            const row = document.createElement("tr");
            row.innerHTML = `
                <td>
                  <input type="hidden" name="InputModel.Attributes[${idx}].Name" value="${col}" />
                  ${col}
                </td>
                <td>
                  <select name="InputModel.Attributes[${idx}].Type">
                    <option value="Numeric" ${isNumeric ? "selected" : ""}>Numeric</option>
                    <option value="Categorical" ${!isNumeric ? "selected" : ""}>Categorical</option>
                  </select>
                </td>
            `;
            tbody.appendChild(row);
        });

        // Switch UI
        switchFormPart("input-dataset-info", "input-attribute-info");
    };

    reader.readAsText(file);
}
const closeAllToolbarPanels = function () {
    $('.toolbar-panel.active-flex').removeClass('active-flex');
}

const toggleToolPanel = function (e, toolPanelId) {
    e.stopPropagation();
    closeAllToolbarPanels();
    $('#' + toolPanelId).toggleClass('active-flex');
}

const openFileBrowser = function (inputId) {
    document.getElementById(inputId).click();
}
const visualSettings = {
    //mono, gradient, category, partition
    currentColourSetting: "partition",
    monoColour: "white",
    backgroundColour:"black",
    gradientColour: {
        currentFeature: "",
        features: {},
        centralities: {}
    },
    categoryColour: {
        currentLabel: "",
        labels: {}
    },
    partitionColour: {},
    currentLabel: "",
    currentNodeSize: ""
}

const initVisualSettings = function () {
    const { num: numAttributes = [], cat: catAttributes = [] } = currentGraph.attributes;
    
    //Add gradient colours in the page list according to initial selected feature
    const gradientColourListId = 'numerical-colour-list';
    const initialGradientColourCount = 3;
    gradientColourList = ['#0000FF', '#FF9933', '#FFFFFF'];
    for (let i = 0; i < initialGradientColourCount; i++) {
        addGradientListColour('attribute-node-colouring-preview', '', gradientColourList[i], gradientColourListId);
    }
    updateGradientLegendAxis('attribute-node-colouring');
    updateGradientLegend('attribute-node-colouring-preview', gradientColourListId);

    //Init feature gradient colours
    if (numAttributes) {
        visualSettings.gradientColour.currentFeature = numAttributes[0];
    }
    for (const feature of numAttributes) {
        //blue, orange and white are initial colours
        const colourObject = [];
        const featureMax = currentGraph.max(feature);
        const featureMin = currentGraph.min(feature);
        const featureRange = featureMax - featureMin;
        
        for (const [i, colour] of gradientColourList.entries()) {
            const valueThreshold = featureMin + (featureRange * (i * (1.0 / (gradientColourList.length - 1))));
            colourObject.push({
                value: valueThreshold,
                colour: colour
            });
        }

        visualSettings.gradientColour.features[feature] = colourObject;
    }
    

    

    
    //Init category colours
    if (catAttributes) {
        visualSettings.categoryColour.currentLabel = catAttributes[0];
    }

    for (const label of catAttributes) {
        const labelDistinctValues = currentGraph.getDistinctValues(label);
        visualSettings.categoryColour.labels[label] = {};
        for (const value of labelDistinctValues) {
            visualSettings.categoryColour.labels[label][value] = groupColours(value);
        }
    }
    changeAttributeCategoryColouringList('categorical-attribute-node-colouring', 'categorical-colour-list');

    //Init partition colours
    const partitionColourList = d3.select("#partition-colour-list").html("");
    const distinctPartitions = currentGraph.getDistinctPartitions();
    for (const partition of distinctPartitions) {
        visualSettings.partitionColour[partition] = addListColour(partition, groupColours(partition), "partition", partitionColourList)
            .property("value");
    }

}

/************************Monochrome colour section**************************/
const setDefaultNodeColour = function (nodes, colour) {
    nodes.style("fill", function (d) {
        const { id } = d;
        const lightness = fontLightness(colour);
        const text = $('#' + id + '_node_text');
        text.css("fill", 'hsl(0, 0%, ' + String(lightness) + '%)')
        return colour;
    });
}

const setDefaultLinkColour = function (links, colour) {
    links.style("stroke", colour);
}

const setDefaultNodeAndLinkColour = function (nodes, links) {
    const defaultNodeColour = document.getElementById("network-colour-input").value;
    setDefaultNodeColour(nodes, defaultNodeColour);
    setDefaultLinkColour(links, defaultNodeColour);
}

const changeNetworkNodeColour = function (colourInputId) {
    const colour = $(`#${colourInputId}`).val();
    visualSettings.currentColourSetting = "mono";
    visualSettings.monoColour = colour;
    setDefaultNodeAndLinkColour(node, link);
}

//*************************Background colour section**********************************/

const changeNetworkBackgroundColour = function (colourInputId) {
    const colour = $(`#${colourInputId}`).val();
    visualSettings.backgroundColour = colour;
    $('#network-background-rect.background').css("fill", colour);
}

//********************************Node label section**********************************/

const enableNodeLabels = function () {
    nodeText.classed('invisible', !nodeVisualProperties.labels.enabled);
}

const setNodeLabel = function (selectElement) {
    const attributeName = selectElement.value;
    const optgroup = selectElement.options[selectElement.selectedIndex].closest('optgroup');
    visualSettings.currentLabel = attributeName;
    if (attributeName === "") {
        nodeText.style("display", "none");
        return;
    }

    nodeText.style("display", "block");

    let getValueFunction = getNodeAttribute;

    if (attributeName === "id") {
        nodeText.text(function (d) {
            return d.id;
        });
        return;
    }

    if (optgroup !== null) {
        const optGroupLabel = optgroup.getAttribute('label');

        if (optGroupLabel === "Centralities") {
            getValueFunction = getNodeProperty;
        }
    }

    nodeText.text(function (d) {
        const attributeValue = getValueFunction(d, attributeName);
        return attributeValue;
    });
}

//************************Gradient colouring section**************************************
const changeAttributeGradientColouringFromSettings = function (attributeSelectId, colourListId) {
    const attributeSelect = document.getElementById(attributeSelectId);
    const optgroup = attributeSelect.options[attributeSelect.selectedIndex].closest('optgroup').getAttribute('label');
    const attributeName = attributeSelect.value;

    let attributeMax = null;
    let attributeMin = null;
    let getValueFunction = null;
    let attributePropertyName = null;
    if (optgroup === "Attributes") {
        attributeMax = currentGraph.max(attributeName);
        attributeMin = currentGraph.min(attributeName);
        getValueFunction = getNodeAttribute;
        attributePropertyName = "features";
    }

    else {
        attributeMax = currentGraph.getPropertyAttributeValue(attributeName, "max");
        attributeMin = currentGraph.getPropertyAttributeValue(attributeName, "min");
        getValueFunction = getNodeProperty;
        attributePropertyName = "centralities";
    }

    const gradientStopColours = d3.selectAll(`#attribute-node-colouring-preview-gradient stop`);

    const colourObject = [];
    gradientStopColours.each(function () {
        const colour = d3.select(this).attr("stop-color");
        const offset = d3.select(this).attr("offset");

        const attributeRange = attributeMax - attributeMin;
        const valueThreshold = attributeMin + (attributeRange * offset);

        colourObject.push({
            value: valueThreshold,
            colour: /*hexToRgb(colour)*/colour
        });

    })

    visualSettings.currentColourSetting = "gradient";
    visualSettings.gradientColour[attributePropertyName][attributeName] = colourObject;
    setAttributeGradientColouring(attributeName, optgroup, getValueFunction, colourObject, attributeMin, attributeMax);
}



const setAttributeGradientColouring = function (attributeName, optgroup, valueFunction, colourObject, attributeMin, attributeMax) {
    node.style("fill", function (d) {
        const attributeValue = valueFunction(d, attributeName);
        if (attributeValue === "") {
            return nodeVisualProperties.colouring.network;
        }

        const finalColour = getGradientColour(colourObject, attributeValue, attributeMin, attributeMax);
        const lightness = fontLightness(finalColour);
        const node_text = $('#' + d.id + '_node_text');
        node_text.css("fill", 'hsl(0, 0%, ' + String(lightness) + '%)');
        return rgbObjectToString(finalColour);
    });
    link.style("stroke", nodeVisualProperties.colouring.network);
}


const updateGradientLegend = function (legendDivId, colourListId) {
    const legendSvg = d3.select(`#${legendDivId}`)
        .select("svg");
    const linearGradient = legendSvg.select("linearGradient");

    const jColourListInputs = $(`#${colourListId} input`);
    const colourCount = jColourListInputs.length;


    const colourData = [];
    let offset = 0;
    const offsetIncrement = 1.0 / (colourCount - 1);
    jColourListInputs.each(function () {
        const colour = $(this).val();
        colourData.push({
            "offset": offset,
            "colour": colour
        });
        offset += offsetIncrement;
    });

    colourData[colourData.length - 1].offset = 1;

    const stopColours = linearGradient
        .html("")
        .selectAll("stop")
        .data(colourData)
        .enter()
        .append("stop")
        .attr("offset", function (d) {
            return d.offset;
        })
        .attr("stop-color", function (d) {
            return d.colour;
        });

    updateGradientLegendPointers(legendSvg, stopColours);
}

const stopColourPolygonDragged = function (d, i) {
    const { dx } = d3.event;
    d.x += dx;
    d.x = Math.max(10, Math.min(d.x, 410));
    const { stopIndex, previousPointerData: prev, nextPointerData: next } = d;

    const colourInputs = document.querySelectorAll("#numerical-colour-list input");
    if (dx < 0 && prev !== null) {
        if (d.x < prev.x) {
            const { previousPointerData: prevPrev } = prev;
            const leftColour = colourInputs[prev.stopIndex].value;
            const rightColour = colourInputs[stopIndex].value;
            colourInputs[stopIndex].value = leftColour;
            colourInputs[prev.stopIndex].value = rightColour;

            [d.stopIndex, d.previousPointerData.stopIndex] = [d.previousPointerData.stopIndex, d.stopIndex];

            if (prevPrev !== null) {
                prevPrev.nextPointerData = d;
            }
            d.previousPointerData = prevPrev;
            d.nextPointerData = prev;

            prev.previousPointerData = d;
            prev.nextPointerData = next;

            if (next !== null) {
                next.previousPointerData = prev;
            }

            const stopColour = document.querySelector(`#attribute-node-colouring-preview stop:nth-child(${prev.stopIndex + 1})`);
            stopColour.setAttribute("offset", (prev.x - 10) / 400.0);
        }
    }

    if (dx > 0 && next !== null) {
        if (d.x > next.x) {
            const { nextPointerData: nextNext } = next;

            const leftColour = colourInputs[stopIndex].value;
            const rightColour = colourInputs[next.stopIndex].value;
            colourInputs[stopIndex].value = rightColour;
            colourInputs[next.stopIndex].value = leftColour;

            [d.stopIndex, d.nextPointerData.stopIndex] = [d.nextPointerData.stopIndex, d.stopIndex];

            if (nextNext !== null) {
                nextNext.previousPointerData = d;
            }

            d.nextPointerData = nextNext;
            d.previousPointerData = next;

            next.nextPointerData = d;
            next.previousPointerData = prev;


            if (prev !== null) {
                prev.nextPointerData = next;
            }

            const stopColour = document.querySelector(`#attribute-node-colouring-preview stop:nth-child(${next.stopIndex + 1})`);
            stopColour.setAttribute("offset", (next.x - 10) / 400.0);
        }
    }


    d3.select(this).attr("transform", `translate(${d.x}, 0)`);
}

const stopColourPolygonDragEnded = function (d) {
    const { dx } = d3.event;
    const legendDivId = "attribute-node-colouring-preview";
    const stops = document.querySelectorAll(`#${legendDivId} linearGradient stop`);


    const newStopOffset = (d.x - 10) / 400.0;
    stops[d.stopIndex].setAttribute("offset", newStopOffset);

    const { previousPointerData: prev, nextPointerData: next } = d;
    if (prev !== null) {
        const newPrevStopOffset = (prev.x - 10) / 400.0;
        stops[prev.stopIndex].setAttribute("offset", newPrevStopOffset);
    }

    if (next !== null) {
        const newNextStopOffset = (next.x - 10) / 400.0;
        stops[next.stopIndex].setAttribute("offset", newNextStopOffset);
    }

    updateGradientColour(legendDivId, "numerical-colour-list")
}

const updateGradientColour = function () {
    const linearGradient = d3.select(`#attribute-node-colouring-preview`)
        .select("svg").select("linearGradient");

    const jColourListInputs = document.querySelectorAll(`#numerical-colour-list input`);

    linearGradient.selectAll("stop")
        .attr("stop-color", function (d, i) {
            return jColourListInputs[i].value;
        })
}


const updateGradientLegendPointers = function (legendSvg, stopColours) {
    legendSvg.select("#stop-colour-pointers").remove();
    const gPointers = legendSvg
        .append("g")
        .attr("transform", "translate(0,30)")
        .attr("id", "stop-colour-pointers");

    const pointerData = [];
    stopColours.each(function (d, i) {
        const x = Math.floor(d.offset * 400) + 10;
        pointerData.push(
            {
                'x': x,
                "stopIndex": i,
            });
    });

    pointerData[pointerData.length - 1].x = 410;

    for (let i = 0; i < pointerData.length; i++) {
        const previousPointerData = i > 0 ? pointerData[i - 1] : null;
        const nextPointerData = i < (pointerData.length - 1) ? pointerData[i + 1] : null;
        pointerData[i].previousPointerData = previousPointerData;
        pointerData[i].nextPointerData = nextPointerData;
    }


    gPointers.selectAll("polygon")
        .data(pointerData)
        .enter()
        .append("polygon")
        .attr("points", function (d) { return `0,15 -7,0 7,0`; })
        .attr("transform", function (d) { return `translate(${d.x}, 0)` })
        .call(d3.drag()
            .on("drag", stopColourPolygonDragged)
            .on("end", stopColourPolygonDragEnded));


}

const updateGradientLegendAxis = function (attributeSelectId) {
    const legendSvg = d3.select(`#attribute-node-colouring-preview svg`)
    const attribute = document.getElementById(attributeSelectId).value;

    const attributeValues = currentGraph.getAllAttributeValues(attribute);
    const xMin = d3.min(attributeValues);
    const xMax = d3.max(attributeValues);

    const axis = createLinearAxis(xMin, xMax, 10, 410);
    const axisLeg = d3.axisBottom(axis);

    legendSvg.select("#gradient-legend-axis").remove();
    legendSvg
        .append("g")
        .attr("transform", "translate(0, 60)")
        .attr("id", "gradient-legend-axis")
        .call(axisLeg);
}

const updateGradientColourList = function (featureSelectId) {
    const featureSelect = document.getElementById(featureSelectId)
    const optgroup = featureSelect.options[featureSelect.selectedIndex].closest('optgroup').getAttribute('label');
    const feature = featureSelect.value;
    const featureList = optgroup === "Attributes" ? visualSettings.gradientColour.features : visualSettings.gradientColour.centralities;
    d3.select("#numerical-colour-list").html("");
    for (const threshold of featureList[feature]) {
        addGradientListColour("attribute-node-colouring-preview", threshold.value.toString(), threshold.colour, "numerical-colour-list")
    }

}

const addGradientListColour = function (legendDivId, label, colour, colourListId) {
    const colourList = d3.select(`#${colourListId}`);
    const idPrefix = colourList.selectAll("li").size();
    if (idPrefix >= 6) {
        return;
    }
    const inputColour = addListColour(label, colour, idPrefix, colourList);
    inputColour
        .on("change", function () { updateGradientColour(legendDivId, colourListId); });
}

//**************Category colouring section*********************
const changeAttributeCategoryColouringList = function (attributeSelectId, colourListId) {
    const attributeName = document.getElementById(attributeSelectId).value;

    if (attributeName === "") {
        return;
    }

    const colourList = d3.select(`#${colourListId}`);

    colourList.html("");
    for (const [value, colour] of Object.entries(visualSettings.categoryColour.labels[attributeName])) {
        addListColour(value, colour, "category", colourList);
    }
}

//TO DO - Get attribute name and colour listin form of object from settings tab
const changeAttributeCategoryColouringFromSettings = function (attributeSelectId, colourListId) {
    const attributeName = document.getElementById(attributeSelectId).value;
    const colourObject = contructColourObjectFromList(colourListId);
    visualSettings.currentColourSetting = "category";
    visualSettings.categoryColour = colourObject;
    
    setAttributeCategoryColouring(attributeName, colourObject);
}

const setAttributeCategoryColouring = function (attributeName, colourObject) {
    node.style("fill", function (d) {
        const attributeValue = getNodeAttribute(d, attributeName);
        if (attributeValue === "") {
            return visualSettings.monoColour;
        }
        const resultColour = hexToRgb(colourObject[attributeValue]);
        const lightness = fontLightness(resultColour);
        const node_text = $('#' + d.id + '_node_text');
        node_text.css("fill", 'hsl(0, 0%, ' + String(lightness) + '%)');
        return rgbObjectToString(resultColour);
    });
    link.style("stroke", function (l) {
        const { id } = l.source;
        const attributeValue = currentGraph.getNodeDataValue(id, attributeName);
        if (isNullOrEmpty(attributeValue)) {
            return
        }

        return isNullOrEmpty(attributeValue) ?
            visualSettings.monoColour:
            colourObject[attributeValue];
    });

    const rects = d3.selectAll("#partition-metric-mcc-graph-container rect");

    rects.style("fill", (d) => {
        return colourObject[d.x];
    });

}

//*************************************Partition colouring section**********************************/
const setPartitionColouring = function (colourListId) {
    const colourObject = contructColourObjectFromList(colourListId);

    visualSettings.currentColourSetting = "partition";
    visualSettings.partitionColour = colourObject;

    d3.selectAll(".selection-panel")
        .style("background-color", function (d) {
            return colourObject[d.id];
        });

    node.style("fill", function (d) {
        const { id } = d;
        const partition = currentGraph.getPartition(id);
        if (partition === "") {
            return nodeVisualProperties.colouring.network;
        }

        const resultColour = hexToRgb(colourObject[partition]);
        const lightness = fontLightness(resultColour);
        const node_text = $('#' + id + '_node_text');
        node_text.css("fill", 'hsl(0, 0%, ' + String(lightness) + '%)');
        return rgbObjectToString(resultColour);
    });
    link.style("stroke", function (l) {
        const { id } = l.source;
        const partition = currentGraph.getPartition(id);
        if (partition === "") {
            return nodeVisualProperties.colouring.network;
        }

        return colourObject[partition];

    });

    const attributeBoxplots = d3.selectAll("#partition-metric-attribute-boxplot-graph-container svg");
    updateBoxplotColour(attributeBoxplots, colourObject);

    const partitionBoxplots = d3.selectAll("#partition-metric-partition-boxplot-graph-container svg");
    partitionBoxplots.each(function (d) {
        updateBoxplotColour(d3.select(this), colourObject[d.id]);
    })

}

const updatePartitionColours = function () {
    for (const partition of selectionGraph.nodes) {
        visualSettings.partitionColour[partition.id] = groupColours(partition.id);
    }
}

const updatePartitionColourList = function () {
    const partitionColourList = d3.select("#partition-colour-list").html("");
    d3.select('#list-selections')
        .selectAll("div")
        .style("background-color", function (d) {
            return addListColour(d.id, visualSettings.partitionColour[d.id], "partition", partitionColourList)
                .property("value");
        });
    
}

//***********************************Node size section********************************************
const setAttributeNodeSizing = function (selectElement) {
    const attributeName = selectElement.value;
    const defaultRadius = currentGraph.getForcePropertyValue(Graph.forceNames.collide, "radius");
    nodeVisualProperties.sizing.attribute = attributeName;

    if (attributeName !== "") {
        nodeVisualProperties.sizing.enabled = true;
        const optgroup = selectElement.options[selectElement.selectedIndex].closest('optgroup').getAttribute('label');
        let attributeMax = null;
        let attributeMin = null;
        let getValueFunction = null;

        if (optgroup === "Attributes") {
            //attributeMax = parseFloat($("#" + attributeName + "-sliderOutputMin").attr("max"));
            //attributeMin = parseFloat($("#" + attributeName + "-sliderOutputMin").attr("min"));
            attributeMax = currentGraph.max(attributeName);
            attributeMin = currentGraph.min(attributeName);
            getValueFunction = getNodeAttribute;

        }

        else if (optgroup === "Centralities") {
            attributeMax = currentGraph.getPropertyAttributeValue(attributeName, "max");
            attributeMin = currentGraph.getPropertyAttributeValue(attributeName, "min");
            getValueFunction = getNodeProperty;

        }

        node.attr("r", function (d) {
            const attributeValue = getValueFunction(d, attributeName);
            if (attributeValue == "") {

                return d.r = defaultRadius / 2;
            }

            const resultRadius = (defaultRadius * 2) * ((attributeValue - attributeMin) / (attributeMax - attributeMin)) + 1;
            return d.r = resultRadius;
        });

        setNodeFontSize();
        return;
    }

    nodeVisualProperties.sizing.enabled = false;
    node.attr("r", function (d) {
        return d.r = defaultRadius;
    });
    setNodeFontSize();
}

//********************************Colour settings utils***************************/

const rgbObjectToString = function (rgbObject) {
    const rgb = 'rgb(' + rgbObject.r + ', '
        + rgbObject.g + ', '
        + rgbObject.b + ')';
    return rgb;
}

const pickHex = function (color1, color2, weight) {
    const w2 = weight;
    const w1 = 1 - w2;
    const rgb = {
        r: Math.round(color1.r * w1 + color2.r * w2),
        g: Math.round(color1.g * w1 + color2.g * w2),
        b: Math.round(color1.b * w1 + color2.b * w2)
    };
    return rgb;
}

const addListColour = function (label, colour, idPrefix, colourList) {
    const labelWithoutWhitespaces = removeSpacesAndCommas(label);
    const id = `${idPrefix}-colour-${labelWithoutWhitespaces}`;
    const newDistinctColourRow = colourList.append("li")
    const newDistinctColourRowDiv = newDistinctColourRow.append("div")
        .classed("colour-row-list", true);
    newDistinctColourRowDiv.append("label")
        .attr("title", label)
        .attr("for", id)
        .html(label);
    const newColorRowInput = newDistinctColourRowDiv.append("input")
        .attr("type", "color")
        .attr("id", id)
        .property("value", colour);
    newDistinctColourRow.on("click", function () {
        newColorRowInput.node().click();
    })

    return newColorRowInput

}

const randomColour = function (brightness) {
    function randomChannel(brightness) {
        var r = 255 - brightness;
        var n = 0 | ((Math.random() * r) + brightness);
        var s = n.toString(16);
        return (s.length == 1) ? '0' + s : s;
    }
    return '#' + randomChannel(brightness) + randomChannel(brightness) + randomChannel(brightness);
}

const randomizeListColours = function (colourListId) {
    d3.selectAll(`#${colourListId} input`)
        .property("value", function () { return randomColour(0); });
}

const contructColourObjectFromList = function (colourListId) {
    const colourList = document.getElementById(`${colourListId}`);

    const colourObject = {};
    for (const colourLI of colourList.children) {
        const distinctPartition = colourLI.querySelector("label").innerHTML;
        const colour = colourLI.querySelector("input").value;
        colourObject[distinctPartition] = colour;
    }

    return colourObject;


}

const hexToRgb = function (hex) {
    // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
    const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    hex = hex.replace(shorthandRegex, function (m, r, g, b) {
        return r + r + g + g + b + b;
    });

    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : null;
}

const fontLightness = function (newColour) {
    const threshold = 0.5;
    let rgbRepresentation = newColour;
    if (typeof newColour !== 'object') {
        rgbRepresentation = hexToRgb(newColour);
    }
    const { r, g, b } = rgbRepresentation;

    const lumaRed = r * 0.2126;
    const lumaGreen = g * 0.7152;
    const lumaBlue = b * 0.0722;

    const lumaSum = lumaRed + lumaGreen + lumaBlue;
    const perceivedLightness = lumaSum / 255;

    const finalLightness = (perceivedLightness - threshold) * -10000000;

    return finalLightness;
}

const getGradientColour = function (colourObject, attributeValue, attributeMin, attributeMax) {
    

    const firstColour = colourObject[0];
    if (attributeValue <= firstColour.value) {
        return hexToRgb(firstColour.colour);
    }

    let lowValueColourRGB = null;
    let highValueColourRGB = null;
    for (let i = 1; i < colourObject.length; i++) {
        if (attributeValue <= colourObject[i].value) {
            lowValueColourRGB = hexToRgb(colourObject[i - 1].colour);
            highValueColourRGB = hexToRgb(colourObject[i].colour);
            const resultValue = ((parseFloat(attributeValue) - attributeMin) / (attributeMax - attributeMin));
            const resultColour = pickHex(lowValueColourRGB, highValueColourRGB, resultValue);
            return resultColour;
        }
    }

    const lastColour = colourObject[colourObject.length - 1];
    return hexToRgb(lastColour.colour);

}

const isLower = function(value1, value2) {
    return value1 < value2;
}

const isGreater = function(value1, value2) {
    return value1 > value2;
}


class FilterCondition {
    
    constructor(booleanFunction) {
        this.booleanFunction = booleanFunction;
    }
};

const lower = new FilterCondition(isLower);
const greater = new FilterCondition(isGreater);


const filterByValue = function (input, filteredAttributeName, filterCondition, minmax) {
    //var value = event.currentTarget.value;

    let value = parseFloat(input.value);
    const extremeValue = parseFloat(!minmax ? input.min : input.max);
    const filterSuffix = !minmax ? "_min" : "_max";
    const attributeFilterType = !minmax ? "low" : "high";
    if (filterCondition.booleanFunction(value, extremeValue)) {
        value = extremeValue;
        input.value = extremeValue;
    }

    const { nodeData: storeNodes, linkData: storeLinks } = dataStore;
    const { nodes: graphNodes, links: graphLinks } = currentGraph;
    const nodeFiltersAttributeName = "filters";
    const linkFilteredName = "filtered";

    for (let i = graphNodes.length - 1; i > -1; i--) {
        const n = graphNodes[i];
        const nodeId = n.id;
        const attributeValue = currentGraph.getNodeDataValue(nodeId, filteredAttributeName);
        if (attributeValue === "")
            continue;

        if (filterCondition.booleanFunction(attributeValue, value)) {
            if (!currentGraph.getNodeDataValue(n.id, nodeFiltersAttributeName)) {
                dataStore.addNewNodeAttribute(nodeId, nodeFiltersAttributeName, []);
                graphNodes.splice(i, 1);
                filterNodeList.push(nodeId);
            }

            const filters = currentGraph.getNodeDataValue(n.id, nodeFiltersAttributeName);
            if (!filters.includes(filteredAttributeName + filterSuffix)) {
                filters.push(filteredAttributeName + filterSuffix);
            }

        }
    }

    for (let i = graphLinks.length - 1; i > -1; i--) {
        const l = graphLinks[i];
        const source = currentGraph.getLinkDataValue(l.id, "source");
        const target = currentGraph.getLinkDataValue(l.id, "target");

        if (filterNodeList.includes(source) || filterNodeList.includes(target)) {
            dataStore.addNewLinkAttribute(l.id, linkFilteredName, true);
            graphLinks.splice(i, 1);          
        }
    }

    for (const [n, nodeData] of Object.entries(storeNodes)) {
        const { [filteredAttributeName]: filAttrVal } = nodeData;
        if (filAttrVal === "")
            continue;

        const { filters } = nodeData;
        if (!filterCondition.booleanFunction(filAttrVal, value) && filters) {
            if (filters.length > 0) {
                for (let i = filters.length - 1; i > -1; i--) {
                    const filterName = filters[i];
                    if (filterName === `${filteredAttributeName}${filterSuffix}`) {
                        filters.splice(i, 1);
                    }
                }

                if (filters.length === 0) {
                    const returningNode = {
                        "id": n
                    };
                    graphNodes.push(returningNode);
                    filterNodeList.splice(filterNodeList.indexOf(n), 1);
                    delete nodeData.filters;
                }
            }
        }
    }
    

    for (const [id, l] of Object.entries(storeLinks)) { 
        const { source, target, value } = l;
        if (!(filterNodeList.includes(source) || filterNodeList.includes(target)) && l.filtered) {
            const returningLink = {
                "id": id,
                "source": source,
                "target": target,
                "value": value
            };
            graphLinks.push(returningLink);
            dataStore.removeLinkAttribute(id, linkFilteredName)
        } 
    };

    updateNodesAndLinks();
    startSimulation();

}

const filterByCategory = function (filteredAttributeName, category, checked) {
    const { nodeData: storeNodes, linkData: storeLinks } = dataStore;
    const { nodes: graphNodes, links: graphLinks } = currentGraph;
    const nodeFiltersAttributeName = "filters";
    const linkFilteredName = "filtered";


    if (!checked) {
        for (let i = graphNodes.length - 1; i > -1; i--) {
            const n = graphNodes[i];
            const nodeId = n.id;
            const attributeValue = currentGraph.getNodeDataValue(nodeId, filteredAttributeName);

            if (attributeValue === category) {
                if (!currentGraph.getNodeDataValue(n.id, nodeFiltersAttributeName)) {
                    dataStore.addNewNodeAttribute(nodeId, nodeFiltersAttributeName, []);
                    graphNodes.splice(i, 1);
                    filterNodeList.push(nodeId);
                }

                const filters = currentGraph.getNodeDataValue(n.id, nodeFiltersAttributeName);
                if (!filters.includes(`${filteredAttributeName}_${category}`)) {
                    filters.push(`${filteredAttributeName}_${category}`);
                }
            }
        }



        for (let i = graphLinks.length - 1; i > -1; i--) {
            const l = graphLinks[i];
            const source = currentGraph.getLinkDataValue(l.id, "source");
            const target = currentGraph.getLinkDataValue(l.id, "target");

            if (filterNodeList.includes(source) || filterNodeList.includes(target)) {
                dataStore.addNewLinkAttribute(l.id, linkFilteredName, true);
                graphLinks.splice(i, 1);
            }
        }
        updateNodesAndLinks();
        startSimulation();
        return;
    }

    for (const [n, nodeData] of Object.entries(storeNodes)) {
        const { [filteredAttributeName]: filAttrVal } = nodeData;
        if (filAttrVal === "")
            return;
        
        const { filters } = nodeData;
        if (filAttrVal === category && filters) {
            if (filters.length > 0) {
                for (let i = filters.length - 1; i > -1; i--) {
                    const filterName = filters[i];
                    if (filterName === `${filteredAttributeName}_${category}`) {
                        filters.splice(i, 1);
                    }
                }

                if (filters.length === 0) {
                    const returningNode = {
                        "id": n
                    };
                    graphNodes.push(returningNode);
                    filterNodeList.splice(filterNodeList.indexOf(n), 1);
                    delete nodeData.filters;
                }
            }
        }
    };

    for (const [id, l] of Object.entries(storeLinks)) { 
        const { source, target } = l;
        if (!(filterNodeList.includes(source) || filterNodeList.includes(target)) && l.filtered) {
            const returningLink = {
                "id": id,
                "source": source,
                "target": target
            };
            graphLinks.push(returningLink);
            dataStore.removeLinkAttribute(id, linkFilteredName)
        } 
    };

    updateNodesAndLinks();
    startSimulation();
   
}

const handleForceEnablement = function(value, force, forceUpdateDelegate){
    currentGraph.setForcePropertyValue(force, "enabled", value)
    forceUpdateDelegate();
    currentGraph.stopSimulation();
    d3.select("#reset-layout-btn")
        .style("color", "red")
        .style("border-color", "red");
    //startSimulation();
}

const handleForceChange = function (value, sliderOutputId, force, property, forceUpdateDelegate) {
    d3.select('#' + sliderOutputId).text(value);
    currentGraph.setForcePropertyValue(force, property, Number(value))
    forceUpdateDelegate();
    currentGraph.stopSimulation();
    d3.select("#reset-layout-btn")
        .style("color", "red")
        .style("border-color", "red");
}

const getNodeAttribute = function (d, attributeName) {
    return currentGraph.getNodeDataValue(d.id, attributeName);
};
const getNodeProperty = function (d, attributeName) {
    return currentGraph.getPropertyValue(d.id, attributeName);;
};

const projectAttributeXAxis = function(selectElement) {
    const attributeName = selectElement.value;

    if (attributeName !== "") {

        const optgroup = selectElement.options[selectElement.selectedIndex].closest('optgroup').getAttribute('label');
        let attributeMax = null;
        let attributeMin = null;

        if (optgroup === "Attributes") {
            attributeMax = parseFloat($("#" + attributeName + "-sliderOutputMin").attr("max"));
            attributeMin = parseFloat($("#" + attributeName + "-sliderOutputMin").attr("min"));
            //node.each(function (d) {
            //    const attributeValue = currentGraph.getNodeDataValue(d.id, attributeName);

            //    if (attributeValue == "") {
            //        d.fx =width / 2;
            //        return;
            //    }
            //    const resultXCoord = width * ((parseFloat(attributeValue) - attributeMin) / (attributeMax - attributeMin)) + 1;
            //    d.fx = resultXCoord;
            //})
           
            currentGraph.updateXForceAttribute(attributeName, attributeMax, attributeMin);
        }

        else if (optgroup === "Centralities"){
            attributeMax = graph.properties[attributeName].max;
            attributeMin = graph.properties[attributeName].min;
            currentGraph.updateXForceProperty(attributeName);
        }
        startSimulation();
        return;
    }

    currentGraph.setDefaultXForce();
    startSimulation();
}


const projectAttributeYAxis = function (selectElement) {
    const attributeName = selectElement.value;

    if (attributeName !== "") {

        const optgroup = selectElement.options[selectElement.selectedIndex].closest('optgroup').getAttribute('label');
        let attributeMax = null;
        let attributeMin = null;

        if (optgroup === "Attributes") {
            attributeMax = parseFloat($("#" + attributeName + "-sliderOutputMin").attr("max"));
            attributeMin = parseFloat($("#" + attributeName + "-sliderOutputMin").attr("min"));
            //node.each(function (d) {
            //    const attributeValue = currentGraph.getNodeDataValue(d.id, attributeName);
            //    if (attributeValue == "") {
            //        d.fy = height / 2;
            //    }

            //    const resultYCoord = height - (height * ((parseFloat(attributeValue) - attributeMin) / (attributeMax - attributeMin)));
            //    d.fy = resultYCoord;
            //});
            
            currentGraph.updateYForceAttribute(attributeName, attributeMax, attributeMin);
        }

        else if (optgroup === "Centralities") {
            attributeMax = graph.properties[attributeName].max;
            attributeMin = graph.properties[attributeName].min;
            currentGraph.updateYForceProperty(attributeName);
        }

        startSimulation();
        return;
    }
    
    currentGraph.setDefaultYForce();
    startSimulation();
}


const createDoubleSlider = function (sliderId, attributeName, minValueId, maxValueId, minValue, maxValue, lowValue = minValue, highValue = maxValue) {
    $("#" + sliderId).slider({
        range: true,
        min: minValue,
        max: maxValue,
        values: [lowValue, highValue],
        step: 0.01,
        stop: function (event, ui) {
            const minValueElem = document.getElementById(minValueId);
            const maxValueElem = document.getElementById(maxValueId);
            minValueElem.value = ui.values[0];
            maxValueElem.value = ui.values[1];

            if (ui.handleIndex === 0) {
                filterByValue(minValueElem, attributeName, lower, false);
            }
            else if (ui.handleIndex === 1) {
                filterByValue(maxValueElem, attributeName, greater, true);
            }
        }
    });

}



const shortestPathsBFS = function (graph) {
    const paths = {};
    const visited = {};
    const { nodes, nodes: { length }, linkedByIndex } = graph;
    
    for (const node1 of nodes) {

        const node1Id = node1.id;
        paths[node1Id] = {}
        visited[node1Id] = {};

        for (const node2 of graph.nodes) {

            const node2Id = node2.id;
            paths[node1Id][node2Id] = Infinity;
            visited[node1Id][node2Id] = false;
        }
    }

    for (const [i, node] of nodes.entries()) {
        const src = node.id;
        paths[src][src] = 0;
        visited[src][src] = true;

        const q = new Queue();
        q.enqueue(src);

        while (!q.isEmpty) {
            const u = q.dequeue();

            for (let j = 0; j < length; j++) {
                const v = nodes[j].id;
                if (visited[src][v] === false && (linkedByIndex[u + "," + v] || linkedByIndex[v + "," + u])) {
                    visited[src][v] = true;
                    paths[src][v] = paths[v][src] = paths[src][u] + 1;
                    q.enqueue(v);
                }
            }
        }

    }

    return paths;
}
// Please see documentation at https://docs.microsoft.com/aspnet/core/client-side/bundling-and-minification
// for details on configuring this project to bundle and minify static web assets.

// Write your JavaScript code.

const openTab = function (event, contentId, divId, contentClass) {
    const tabcontents = document.getElementById(divId).querySelectorAll(contentClass);
    for (const tabcontent of tabcontents) {
        tabcontent.classList.remove("active-block");
    }

    const tablinks = document.getElementById(divId).querySelectorAll(".tab-link");
    for (const tablink of tablinks) {
        tablink.className = tablink.className.replace(" tab-active", "");
    }

    document.getElementById(contentId).classList.add("active-block");
    event.currentTarget.className += " tab-active";
}

const getJsonValue = function (obj, stringPath) {
    let result = stringPath.split('.').reduce(function (o, k) {
        return o && o[k];
    }, obj);
    return result;
}

const cancelDefaultBehaviour = function (e) {
    e.preventDefault();
    e.stopPropagation();
    return false;
}

const removeSpacesAndCommas = function (inputString) {
    return inputString.replace(/[\s,]+/g, '-');
}

const clearElement = function (id) {
    document.getElementById(id).innerHTML = "";
}

const switchElement = function (groupClass, activeId, diplayType) {
    $(`.${groupClass}`).css("display", "none");
    document.getElementById(activeId).style.display = diplayType;
}

window.addEventListener("load", function () {
    //$('.collapse.in').prev('.panel-heading').addClass('active');
    //$('#accordion')
    //    .on('show.bs.collapse', function (a) {
    //        $(a.target).prev('.panel-heading').addClass('active');
    //    })
    //    .on('hide.bs.collapse', function (a) {
    //        $(a.target).prev('.panel-heading').removeClass('active');
    //    });

    document.addEventListener('click', closeAllToolbarPanels);
    //initiateEventHandlers();
    
    prepareInputForm();
    calculateAllMetrics();

    prepareNodeDatalist();

    const { num: numAttributes = [] } = currentGraph.attributes;
    for (const attribute of numAttributes) {
        const containerDivId = `${attribute}-histogram-container`;
        const attributeValues = currentGraph.getAllAttributeValues(attribute);

        hist(containerDivId, attributeValues, attribute, 300, 100);
        
    }

    updateRemodelOptionsHeader("remodel-attribute-panel-header", "remodel-network-select");
    displayAlgorithmParameters("remodel-algorithm-select", "-parameters-remodel");
    displayMetricParameters("remodel-metric-select");

    addSelectionDivs(selectionGraph);
    updateSelectionNodesAndLinks();
    updatePartitionColours();
    updatePartitionColourList();
    setPartitionColouring("partition-colour-list");

});







(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-dispatch'), require('d3-drag'), require('d3-interpolate'), require('d3-selection'), require('d3-transition')) :
        typeof define === 'function' && define.amd ? define(['exports', 'd3-dispatch', 'd3-drag', 'd3-interpolate', 'd3-selection', 'd3-transition'], factory) :
            (factory((global.d3 = global.d3 || {}), global.d3, global.d3, global.d3, global.d3, global.d3));
}(this, (function (exports, d3Dispatch, d3Drag, d3Interpolate, d3Selection, d3Transition) {
    'use strict';

    var constant = function (x) {
        return function () {
            return x;
        };
    };

    var BrushEvent = function (target, type, selection) {
        this.target = target;
        this.type = type;
        this.selection = selection;
    };

    function nopropagation() {
        d3Selection.event.stopImmediatePropagation();
    }

    var noevent = function () {
        d3Selection.event.preventDefault();
        d3Selection.event.stopImmediatePropagation();
    };

    var MODE_DRAG = { name: "drag" };
    var MODE_SPACE = { name: "space" };
    var MODE_HANDLE = { name: "handle" };
    var MODE_CENTER = { name: "center" };

    var X = {
        name: "x",
        handles: ["e", "w"].map(type),
        input: function (x, e) { return x && [[x[0], e[0][1]], [x[1], e[1][1]]]; },
        output: function (xy) { return xy && [xy[0][0], xy[1][0]]; }
    };

    var Y = {
        name: "y",
        handles: ["n", "s"].map(type),
        input: function (y, e) { return y && [[e[0][0], y[0]], [e[1][0], y[1]]]; },
        output: function (xy) { return xy && [xy[0][1], xy[1][1]]; }
    };

    var XY = {
        name: "xy",
        handles: ["n", "e", "s", "w", "nw", "ne", "se", "sw"].map(type),
        input: function (xy) { return xy; },
        output: function (xy) { return xy; }
    };

    var cursors = {
        overlay: "crosshair",
        selection: "move",
        n: "ns-resize",
        e: "ew-resize",
        s: "ns-resize",
        w: "ew-resize",
        nw: "nwse-resize",
        ne: "nesw-resize",
        se: "nwse-resize",
        sw: "nesw-resize"
    };

    var flipX = {
        e: "w",
        w: "e",
        nw: "ne",
        ne: "nw",
        se: "sw",
        sw: "se"
    };

    var flipY = {
        n: "s",
        s: "n",
        nw: "sw",
        ne: "se",
        se: "ne",
        sw: "nw"
    };

    var signsX = {
        overlay: +1,
        selection: +1,
        n: null,
        e: +1,
        s: null,
        w: -1,
        nw: -1,
        ne: +1,
        se: +1,
        sw: -1
    };

    var signsY = {
        overlay: +1,
        selection: +1,
        n: -1,
        e: null,
        s: +1,
        w: null,
        nw: -1,
        ne: -1,
        se: +1,
        sw: +1
    };

    function type(t) {
        return { type: t };
    }

    // Ignore right-click, since that should open the context menu.
    function defaultFilter() {
        return !d3Selection.event.button;
    }

    function defaultExtent() {
        var svg = this.ownerSVGElement || this;
        return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
    }

    // Like d3.local, but with the name __brush rather than auto-generated.
    function local(node) {
        while (!node.__brush) if (!(node = node.parentNode)) return;
        return node.__brush;
    }

    function empty(extent) {
        return extent[0][0] === extent[1][0]
            || extent[0][1] === extent[1][1];
    }

    function brushSelection(node) {
        var state = node.__brush;
        return state ? state.dim.output(state.selection) : null;
    }

    function brushX() {
        return brush$1(X);
    }

    function brushY() {
        return brush$1(Y);
    }

    var brush = function () {
        return brush$1(XY);
    };

    function brush$1(dim) {
        var extent = defaultExtent,
            filter = defaultFilter,
            listeners = d3Dispatch.dispatch(brush, "start", "brush", "end"),
            handleSize = 6,
            touchending;

        function brush(group) {

            var overlay = group
                .property("__brush", initialize)
                .selectAll(".overlay")
                .data([type("overlay")]);

            overlay.enter().append("rect")
                .attr("class", "overlay")
                .attr("pointer-events", "all")
                .attr("cursor", cursors.overlay)
                .merge(overlay)
                .each(function () {
                    var extent = local(this).extent;
                    d3Selection.select(this)
                        .attr("x", extent[0][0])
                        .attr("y", extent[0][1])
                        .attr("width", extent[1][0] - extent[0][0])
                        .attr("height", extent[1][1] - extent[0][1]);
                });

            group.selectAll(".selection")
                .data([type("selection")])
                .enter().append("rect")
                .attr("class", "selection")
                .attr("cursor", cursors.selection)
                .attr("fill", "#777")
                .attr("fill-opacity", 0.3)
                .attr("stroke", "#fff")
                .attr("shape-rendering", "crispEdges");

            var handle = group.selectAll(".handle")
                .data(dim.handles, function (d) { return d.type; });

            handle.exit().remove();

            handle.enter().append("rect")
                .attr("class", function (d) { return "handle handle--" + d.type; })
                .attr("cursor", function (d) { return cursors[d.type]; });

            group
                .each(redraw)
                .attr("fill", "none")
                .attr("pointer-events", "all")
                .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)")
                .on("mousedown.brush touchstart.brush", started);
        }

        brush.move = function (group, selection) {
            if (group.selection) {
                group
                    .on("start.brush", function () { emitter(this, arguments).beforestart().start(); })
                    .on("interrupt.brush end.brush", function () { emitter(this, arguments).end(); })
                    .tween("brush", function () {
                        var that = this,
                            state = that.__brush,
                            emit = emitter(that, arguments),
                            selection0 = state.selection,
                            selection1 = dim.input(typeof selection === "function" ? selection.apply(this, arguments) : selection, state.extent),
                            i = d3Interpolate.interpolate(selection0, selection1);

                        function tween(t) {
                            state.selection = t === 1 && empty(selection1) ? null : i(t);
                            redraw.call(that);
                            emit.brush();
                        }

                        return selection0 && selection1 ? tween : tween(1);
                    });
            } else {
                group
                    .each(function () {
                        var that = this,
                            args = arguments,
                            state = that.__brush,
                            selection1 = dim.input(typeof selection === "function" ? selection.apply(that, args) : selection, state.extent),
                            emit = emitter(that, args).beforestart();

                        d3Transition.interrupt(that);
                        state.selection = selection1 == null || empty(selection1) ? null : selection1;
                        redraw.call(that);
                        emit.start().brush().end();
                    });
            }
        };

        function redraw() {
            var group = d3Selection.select(this),
                selection = local(this).selection;

            if (selection) {
                group.selectAll(".selection")
                    .style("display", null)
                    .attr("x", selection[0][0])
                    .attr("y", selection[0][1])
                    .attr("width", selection[1][0] - selection[0][0])
                    .attr("height", selection[1][1] - selection[0][1]);

                group.selectAll(".handle")
                    .style("display", null)
                    .attr("x", function (d) { return d.type[d.type.length - 1] === "e" ? selection[1][0] - handleSize / 2 : selection[0][0] - handleSize / 2; })
                    .attr("y", function (d) { return d.type[0] === "s" ? selection[1][1] - handleSize / 2 : selection[0][1] - handleSize / 2; })
                    .attr("width", function (d) { return d.type === "n" || d.type === "s" ? selection[1][0] - selection[0][0] + handleSize : handleSize; })
                    .attr("height", function (d) { return d.type === "e" || d.type === "w" ? selection[1][1] - selection[0][1] + handleSize : handleSize; });
            }

            else {
                group.selectAll(".selection,.handle")
                    .style("display", "none")
                    .attr("x", null)
                    .attr("y", null)
                    .attr("width", null)
                    .attr("height", null);
            }
        }

        function emitter(that, args) {
            return that.__brush.emitter || new Emitter(that, args);
        }

        function Emitter(that, args) {
            this.that = that;
            this.args = args;
            this.state = that.__brush;
            this.active = 0;
        }

        Emitter.prototype = {
            beforestart: function () {
                if (++this.active === 1) this.state.emitter = this, this.starting = true;
                return this;
            },
            start: function () {
                if (this.starting) this.starting = false, this.emit("start");
                return this;
            },
            brush: function () {
                this.emit("brush");
                return this;
            },
            end: function () {
                if (--this.active === 0) delete this.state.emitter, this.emit("end");
                return this;
            },
            emit: function (type) {
                d3Selection.customEvent(new BrushEvent(brush, type, dim.output(this.state.selection)), listeners.apply, listeners, [type, this.that, this.args]);
            }
        };

        function started() {
            if (d3Selection.event.touches) { if (d3Selection.event.changedTouches.length < d3Selection.event.touches.length) return noevent(); }
            else if (touchending) return;
            if (!filter.apply(this, arguments)) return;

            var that = this,
                type = d3Selection.event.target.__data__.type,
                mode = (d3Selection.event.metaKey ? type = "overlay" : type) === "selection" ? MODE_DRAG : (d3Selection.event.altKey ? MODE_CENTER : MODE_HANDLE),
                signX = dim === Y ? null : signsX[type],
                signY = dim === X ? null : signsY[type],
                state = local(that),
                extent = state.extent,
                selection = state.selection,
                W = extent[0][0], w0, w1,
                N = extent[0][1], n0, n1,
                E = extent[1][0], e0, e1,
                S = extent[1][1], s0, s1,
                dx,
                dy,
                moving,
                lockX,
                lockY,
                point0 = d3Selection.mouse(that),
                point = point0,
                emit = emitter(that, arguments).beforestart();

            if (type === "overlay") {
                state.selection = selection = [
                    [w0 = dim === Y ? W : point0[0], n0 = dim === X ? N : point0[1]],
                    [e0 = dim === Y ? E : w0, s0 = dim === X ? S : n0]
                ];
            } else {
                w0 = selection[0][0];
                n0 = selection[0][1];
                e0 = selection[1][0];
                s0 = selection[1][1];
            }

            w1 = w0;
            n1 = n0;
            e1 = e0;
            s1 = s0;

            var group = d3Selection.select(that)
                .attr("pointer-events", "none");

            var overlay = group.selectAll(".overlay")
                .attr("cursor", cursors[type]);

            if (d3Selection.event.touches) {
                group
                    .on("touchmove.brush", moved, true)
                    .on("touchend.brush touchcancel.brush", ended, true);
            } else {
                var view = d3Selection.select(d3Selection.event.view)
                    .on("keydown.brush", keydowned, true)
                    .on("keyup.brush", keyupped, true)
                    .on("mousemove.brush", moved, true)
                    .on("mouseup.brush", ended, true);

                d3Drag.dragDisable(d3Selection.event.view);
            }

            nopropagation();
            d3Transition.interrupt(that);
            redraw.call(that);
            emit.start();

            function moved() {
                var point1 = d3Selection.mouse(that);
                point = point1;
                moving = true;
                noevent();
                move();
            }

            function move() {
                var t;

                dx = point[0] - point0[0];
                dy = point[1] - point0[1];

                switch (mode) {
                    case MODE_SPACE:
                    case MODE_DRAG: {
                        if (signX) dx = Math.max(W - w0, Math.min(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
                        if (signY) dy = Math.max(N - n0, Math.min(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
                        break;
                    }
                    case MODE_HANDLE: {
                        if (signX < 0) dx = Math.max(W - w0, Math.min(E - w0, dx)), w1 = w0 + dx, e1 = e0;
                        else if (signX > 0) dx = Math.max(W - e0, Math.min(E - e0, dx)), w1 = w0, e1 = e0 + dx;
                        if (signY < 0) dy = Math.max(N - n0, Math.min(S - n0, dy)), n1 = n0 + dy, s1 = s0;
                        else if (signY > 0) dy = Math.max(N - s0, Math.min(S - s0, dy)), n1 = n0, s1 = s0 + dy;
                        break;
                    }
                    case MODE_CENTER: {
                        if (signX) w1 = Math.max(W, Math.min(E, w0 - dx * signX)), e1 = Math.max(W, Math.min(E, e0 + dx * signX));
                        if (signY) n1 = Math.max(N, Math.min(S, n0 - dy * signY)), s1 = Math.max(N, Math.min(S, s0 + dy * signY));
                        break;
                    }
                }

                if (e1 < w1) {
                    signX *= -1;
                    t = w0, w0 = e0, e0 = t;
                    t = w1, w1 = e1, e1 = t;
                    if (type in flipX) overlay.attr("cursor", cursors[type = flipX[type]]);
                }

                if (s1 < n1) {
                    signY *= -1;
                    t = n0, n0 = s0, s0 = t;
                    t = n1, n1 = s1, s1 = t;
                    if (type in flipY) overlay.attr("cursor", cursors[type = flipY[type]]);
                }

                if (state.selection) selection = state.selection; // May be set by brush.move!
                if (lockX) w1 = selection[0][0], e1 = selection[1][0];
                if (lockY) n1 = selection[0][1], s1 = selection[1][1];

                if (selection[0][0] !== w1
                    || selection[0][1] !== n1
                    || selection[1][0] !== e1
                    || selection[1][1] !== s1) {
                    state.selection = [[w1, n1], [e1, s1]];
                    redraw.call(that);
                    emit.brush();
                }
            }

            function ended() {
                nopropagation();
                if (d3Selection.event.touches) {
                    if (d3Selection.event.touches.length) return;
                    if (touchending) clearTimeout(touchending);
                    touchending = setTimeout(function () { touchending = null; }, 500); // Ghost clicks are delayed!
                    group.on("touchmove.brush touchend.brush touchcancel.brush", null);
                } else {
                    d3Drag.dragEnable(d3Selection.event.view, moving);
                    view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
                }
                group.attr("pointer-events", "all");
                overlay.attr("cursor", cursors.overlay);
                if (state.selection) selection = state.selection; // May be set by brush.move (on start)!
                if (empty(selection)) state.selection = null, redraw.call(that);
                emit.end();
            }

            function keydowned() {
                switch (d3Selection.event.keyCode) {
                    case 18: { // ALT
                        if (mode === MODE_HANDLE) {
                            if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
                            if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
                            mode = MODE_CENTER;
                            move();
                        }
                        break;
                    }
                    case 32: { // SPACE; takes priority over ALT
                        if (mode === MODE_HANDLE || mode === MODE_CENTER) {
                            if (signX < 0) e0 = e1 - dx; else if (signX > 0) w0 = w1 - dx;
                            if (signY < 0) s0 = s1 - dy; else if (signY > 0) n0 = n1 - dy;
                            mode = MODE_SPACE;
                            overlay.attr("cursor", cursors.selection);
                            move();
                        }
                        break;
                    }
                    default: return;
                }
                noevent();
            }

            function keyupped() {
                switch (d3Selection.event.keyCode) {
                    case 18: { // ALT
                        if (mode === MODE_CENTER) {
                            if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
                            if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
                            mode = MODE_HANDLE;
                            move();
                        }
                        break;
                    }
                    case 32: { // SPACE
                        if (mode === MODE_SPACE) {
                            if (d3Selection.event.altKey) {
                                if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
                                if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
                                mode = MODE_CENTER;
                            } else {
                                if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
                                if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
                                mode = MODE_HANDLE;
                            }
                            overlay.attr("cursor", cursors[type]);
                            move();
                        }
                        break;
                    }
                    default: return;
                }
                noevent();
            }
        }

        function initialize() {
            var state = this.__brush || { selection: null };
            state.extent = extent.apply(this, arguments);
            state.dim = dim;
            return state;
        }

        brush.extent = function (_) {
            return arguments.length ? (extent = typeof _ === "function" ? _ : constant([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), brush) : extent;
        };

        brush.filter = function (_) {
            return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), brush) : filter;
        };

        brush.handleSize = function (_) {
            return arguments.length ? (handleSize = +_, brush) : handleSize;
        };

        brush.on = function () {
            var value = listeners.on.apply(listeners, arguments);
            return value === listeners ? brush : value;
        };

        return brush;
    }

    exports.brush = brush;
    exports.brushX = brushX;
    exports.brushY = brushY;
    exports.brushSelection = brushSelection;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//////////SAVE GRAPH///////////


const serializeNumericFilters = function (filterDiv) {
    const numericFilters = filterDiv.getElementsByClassName('numeric');

    const resultFilters = [];
    for (const numericFilter of numericFilters) {
        const attributeName = numericFilter.querySelector('h4').innerHTML;
        const minInput = numericFilter.querySelector("#" + attributeName + "-sliderOutputMin");
        const maxInput = numericFilter.querySelector("#" + attributeName + "-sliderOutputMax");
        const filterJson = {
            "attribute": attributeName,
            "min": parseFloat(minInput.min),
            "max": parseFloat(maxInput.max),
            "lowValue": parseFloat(minInput.value),
            "highValue": parseFloat(maxInput.value)
        };
        resultFilters.push(filterJson);
    }
    parseFloat()
    return resultFilters;
}

const serializeCategoricalFilters = function (filterDiv) {
    const categoricalFilters = filterDiv.getElementsByClassName('categorical');

    const resultFilters = [];
    for (const categoricalFilter of categoricalFilters) {
        const attributeName = categoricalFilter.querySelector('h4').innerHTML;
        const checkboxes = categoricalFilter.querySelectorAll('input');
        const filterJson = {
            "attribute": attributeName,
            "categories": {}
        }
        for (const checkbox of checkboxes) {
            const category = checkbox.value;
            const checked = checkbox.checked;
            filterJson.categories[category] = checked;
        }

        resultFilters.push(filterJson);
    }

    return resultFilters;
}

const serializeFilters = function () {
    const filterDiv = document.getElementById('attributes');

    const filters = {
        "numeric": serializeNumericFilters(filterDiv),
        "categorical": serializeCategoricalFilters(filterDiv)
    };

    return filters;
}

const serializeGraph = function (graph) {
    const serializedGraph = structuredClone(graph);
    const { links } = serializedGraph;

    //for (let i = 0; i < links.length; i++) {
    //    links[i].source = links[i].source.id;
    //    links[i].target = links[i].target.id;
    //}

    for (const link of links) {
        link.source = link.source.id;
        link.target = link.target.id;
    }

    return serializeGraph;
}

const getColourListInputSelector = function (colourListId) {
    return `#${colourListId} input[type=color]`;
}
const serializeGradientColouring = function () {
    const chosenNumAttributeForColouring = document.getElementById("attribute-node-colouring").value;
    const gPointers = d3.selectAll("#stop-colour-pointers polygon");

    const gradientPointerData = [];
    
    gPointers.each(function (d) {
        gradientPointerData.push(d.x);
    });

    const gradientAxisColours = [];
    const gradientAxisColourInputs = document.querySelectorAll(getColourListInputSelector("numerical-colour-list"));
    for (const colourInput of gradientAxisColourInputs) {
        gradientAxisColours.push(colourInput.value);
    }

    const gradientColouringObject = {
        "attribute": chosenNumAttributeForColouring,
        "pointers": {
            "data": gradientPointerData,
        },
        "colours": gradientAxisColours
    }

    return gradientColouringObject;
}

const serializeColourList = function (colourListId) {
    const colourList = document.getElementById(colourListId);
    const colorListItems = colourList.getElementsByTagName("li");
    const colours = [];

    for (const colourListItem of colorListItems) {
        const colourObject = {
            "value": colourListItem.querySelector("label").textContent,
            "colour": colourListItem.querySelector("input").value
        }
        colours.push(colourObject);
    }

    return colours;
}

const serializeCategoryColouring = function () {
    const chosenNumAttributeForColouring = document.getElementById("categorical-attribute-node-colouring").value;
    const categoricalColours = serializeColourList("categorical-colour-list");

    const categoricalColouringObject = {
        "attribute": chosenNumAttributeForColouring,
        "colours": categoricalColours 
    }

    return categoricalColouringObject;
}



const serializePartitionColouring = function () {
    const partitionColours = serializeColourList("partition-colour-list")

    const partitionColouringObject = {
        "colours": partitionColours
    }

    return partitionColouringObject;
}

const serializeClassColouring = function () {
    const partitionColours = serializeColourList("class-colour-list")

    const classColouringObject = {
        "colours": partitionColours
    }

    return classColouringObject;
}

const serializeVisuals = function () {
    const monoColour = document.getElementById("network-colour-input").value;
    const gradientColourObject = serializeGradientColouring();
    const categoricalColourObject = serializeCategoryColouring();
    const partitionColourObject = serializePartitionColouring();
    const classColourObject = serializeClassColouring();

    const visualsObject = {
        "monoColour": monoColour,
        "gradient": gradientColourObject,
        "categorical": categoricalColourObject,
        "partition": partitionColourObject,
        "class": classColourObject
    }

    return visualsObject;
}

const serializeNetworkAndSettings = function () {
    const serializedCurrentGraph = currentGraph.serialize();
    const serializedSelectionGraph = serializeGraph(selectionGraph);
    //const filters = serializeFilters();
    //const visuals = serializeVisuals();

    const currentGraphObject = {
        "graph": serializedCurrentGraph,
        "selectionGraph": serializedSelectionGraph,
        //"filters": filters,
        //"filterNodeList": filterNodeList,
       
        //"nodeVisualProperties": nodeVisualProperties
    }


    const stateJson = {
        "currentGraph": currentGraphObject,
        "data": dataStore.serialize(),
        "visualSettings": visualSettings,
        "remodelSettings": currentRemodelSettings
    }

    return stateJson;
}

const saveGraph = function (fileName) {
    var a = document.createElement("a");
    const stateJson = serializeNetworkAndSettings();
    var file = new Blob([JSON.stringify(stateJson, null, 2)], { type: "application/json" });
    a.href = URL.createObjectURL(file);
    a.download = fileName;
    a.click();
}

//////////////////LOAD GRAPH/////////////////////////

const loadNetwork = async function (fileName) {

    //DELETE RETURN LATER TO ENABLE FUNCTION!!!!!!
    
    var reader = new FileReader();
    reader.onload = function (e) {
        clearGraphElementsAndControls();
       
        var json = JSON.parse(e.target.result);
        const graphs = json.currentGraph;
        const { graph, selectionGraph: clusterGraph } = graphs;
        const { data, visualSettings: visuals, remodelSettings } = json;
        

        currentGraph.deserialize(graph);
        dataStore.deserialize(data);
        selectionGraph = clusterGraph;
        visualSettings = visuals;
        currentRemodelSettings = remodelSettings;

        prepareCanvas();
        drawNetwork();
        drawHeatmap(graph.similarityMatrix);
        updateForces();
        setDefaultNodeAndLinkColour(node, link);


        addSelectionDivs();
        updatePartitionColourList();

        generateGraphControlsAndElements();


        //// TODO: Load Metrics from json file
        //calculateAllMetrics();
    };
    reader.readAsText(fileName);
}

const exportNetworkDataToCsv = function () {
    const data = currentGraph.nodes;
    // 1. Headers
    const headers = Object.keys(Object.values(dataStore.nodeData)[0]).concat("cluster");

    // 2. Rows
    const rows = data.map(node => {
        const cluster = currentGraph.getPartition(node.id); // join via id
        return Object.values(currentGraph.getAllNodeData[node.id]).concat(cluster);
    });

    // 3. Build CSV string (escape values if needed)
    const csv = [
        headers.join(";"),
        ...rows.map(r => r.join(";"))
    ].join("\n");

    // 4. Create downloadable blob
    const blob = new Blob([csv], { type: "text/csv" });
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;
    a.download = "data.csv";
    a.click();

    URL.revokeObjectURL(url);

}
////function toggleNodeDetails(nodeId, headingId, detailsId, nodeRowGroupId) {
////    let headingElement = document.getElementById(headingId);
////    let detailsElement = document.getElementById(detailsId);

////    if (detailsElement.style.display === 'none' || detailsElement.style.display === '') {
////        detailsElement.style.display = 'block';
////        let inputs = detailsElement.querySelectorAll('input');

////        inputs.forEach((input) => {
////            let attributeName = input.id.substring(input.id.indexOf('-') + 1, input.id.length);
////            input.value = graph.nodes[nodeId][attributeName];
////        });

////    }

////    else {
////        if (!headingElement.classList.contains('active-node-heading')) {
////            let rowHeadings = $('#' + nodeRowGroupId + ' .active-node-heading');

////            rowHeadings.removeClass('active-node-heading');

////            let inputs = detailsElement.querySelectorAll('input');

////            inputs.forEach((input) => {
////                let attributeName = input.id.substring(input.id.indexOf('-') + 1, input.id.length);
////                input.value = graph.nodes[nodeId][attributeName];
////            });

////        }
////        else {
////            detailsElement.style.display = 'none';
////        }
////    }

////    headingElement.classList.toggle('active-node-heading');
////}

const prepareNodeDatalist = function () {
    const nodeInput = document.getElementById("node-list-input");
    const nodeDataList = document.getElementById("node-list");

    nodeInput.addEventListener("focus", showNodeDataList)
    nodeInput.addEventListener("keyup", filterNodeSearchList);
    nodeInput.addEventListener("blur", function(){
        nodeDataList.classList.remove("active-block");
    });
    nodeInput.addEventListener("mousedown", function () {
        if (document.activeElement === nodeInput) {
            nodeInput.blur();
        }
    })

}

const showNodeDataList = function () {
    const nodeDataList = document.getElementById("node-list");
    nodeDataList.classList.add('active-block');
    
}

const filterNodeSearchList = function () {
    const nodeInput = document.getElementById("node-list-input");
    const filterValue = nodeInput.value.toLowerCase();
    const nodeList = document.getElementById("node-list");
    const nodeListItems = nodeList.getElementsByTagName("*");

    for (const nodeListItem of nodeListItems) {
        const nodeId = nodeListItem.textContent;
        if (nodeId.startsWith(filterValue)) {
            nodeListItem.style.display = "";
            continue;
        }
        nodeListItem.style.display = "none";
    }
}
const nodeHeadingClick = function (nodeId, nodeIndex) {
    selectNode(nodeId);
    toggleNodeDetails(nodeId, nodeIndex);
    
    showNodeNeighbors(nodeId);
}

const nodeHeadingMouseOver = function (nodeId, opacity) {
    fadeDisconnectedNodes(nodeId, opacity);
}

const selectNode = function (nodeId) {
    deselectAllNodes();
    nodeGroups.classed('selected', function (d) {
        return d.selected = d.selected | d.id == nodeId;
    });
}

const toggleNodeDetails = function (nodeId, nodeIndex) {
    const nodeInput = document.getElementById("node-list-input");
    nodeInput.value = nodeId;
    const detailsElement = document.getElementById("node-detail-container");
    const attributesDiv = document.getElementById("node-attributes");
    const centralitiesDiv = document.getElementById("node-centralities");

    detailsElement.setAttribute('data-id', nodeId)

    if (detailsElement.style.display === 'none' || detailsElement.style.display === '') {
        detailsElement.style.display = 'block';
    }

    let inputs = attributesDiv.getElementsByTagName('input');

    for (const input of inputs) {
        //let attributeName = input.id.substring(input.id.indexOf('-') + 1, input.id.length);
        const attributeName = input.getAttribute('data-attribute');
        const attributeValue = currentGraph.getNodeDataValue(nodeId, attributeName);
        input.value = attributeValue;
        input.setAttribute("title", attributeValue);
    };

    showNodeValueInHistogram(nodeId, nodeIndex, attributesDiv);

    inputs = centralitiesDiv.getElementsByTagName('input');

    for (const input of inputs) {
        //let attributeName = input.id.substring(input.id.indexOf('-') + 1, input.id.length);
        const attributeName = input.getAttribute('data-attribute');
        const attributeValue = currentGraph.getPropertyValue(nodeId, attributeName)
        input.value = attributeValue !== undefined ? attributeValue : "Calculating";
        
    };

    
}

const showNodeValueInHistogram = function (nodeId, nodeIndex, attributeDiv = null) {
    if (attributeDiv === null) {
        attributeDiv = document.getElementById("node-attributes");
    }
    const histogramSvgs = attributeDiv.getElementsByTagName("svg");
    for (const histogram of histogramSvgs) {
        //const d3Histogram = d3.select(histogram);
        const attributeName = histogram.getAttribute('data-attribute');
        const attributeValue = currentGraph.getNodeDataValue(nodeId, attributeName);
        const bins = histogram.getElementsByTagName("rect");
        d3.selectAll(bins)
            .style("fill", function (d) {
                if (d.x0 <= attributeValue && d.x1 > attributeValue) {
                    return "red";
                }
                return "#ffeead";
            });
    }
}

const showNodeValuesInHistogram = function (nodes, attributeDiv = null) {
    if (attributeDiv === null) {
        attributeDiv = document.getElementById("node-attributes");
    }
    const histogramSvgs = attributeDiv.getElementsByTagName("svg");
    for (const histogram of histogramSvgs) {
        //const d3Histogram = d3.select(histogram);
        const attributeName = histogram.getAttribute('data-attribute');
        const bins = histogram.getElementsByTagName("rect");
        const d3bins = d3.selectAll(bins).style("fill", "#ffeead");
        nodes.each(function (n) {
            const attributeValue = currentGraph.getNodeDataValue(n.id, attributeName);
            d3bins.each(function (d) {
                if (d.x0 <= attributeValue && d.x1 > attributeValue) {
                    d3.select(this).style("fill",(b) => "red");
                }
            })
        });
    }
}

const showNodeNeighbors = function (nodeId) {
    const neighborsContainer = document.getElementById("node-neighbors-section");

    const neighborsHeadlineElement = neighborsContainer.firstElementChild;
    neighborsHeadlineElement.innerHTML = `Node \"${nodeId}\" neighbors`;

    createNeighborHeadings(nodeId);
    
}

const createNeighborHeadings = function (nodeId) {
    const neighborsGridElement = d3.select("#neighbors-nav");
    neighborsGridElement.html("");
    const headingData = [];

    for (const link of currentGraph.links) {
        let neighbor = null;
        if (link.source.id === nodeId) {
            neighbor = link.target;
        }
        if (link.target.id === nodeId) {
            neighbor = link.source;
        }

        if (neighbor != null) {
            const { id: neighborId, index: neighborIndex } = neighbor;
            headingData.push({
                nodeId: neighborId,
                index: neighborIndex
            })
        }
        
    }

    neighborsGridElement
        .on("click", function () {
            const { nodeId, index } = d3.event.target.__data__;
            nodeHeadingClick(nodeId, index);
        })
        .selectAll("div")
        .data(headingData)
        .enter()
        .append("div")
            .classed("node-heading", true)
            .attr("role", "tab")
            .attr("id", (d) => `neighbor-heading-${d.nodeId}` )
            .append("h5")
                .html((d) => d.nodeId);

}






class Queue {
    constructor() {
        this.data = {};
        this.head = 0;
        this.tail = 0;
    }

    enqueue(element) {
        this.data[this.tail] = element;
        this.tail++;
    }

    dequeue() {
        const element = this.data[this.head];
        delete this.data[this.head];
        this.head++;
        return element;
    }

    peek() {
        return this.data[this.head];
    }

    get length() {
        return this.tail - this.head;
    }

    get isEmpty(){
        return this.length === 0;
    }
}

const inputColorClick = function(selection_panel) {
    selection_panel.querySelector('input').click();
}

const stopClickPropagation = function(event) {
    event.stopPropagation();
}

const selectNodesBySelection = function(selectionId, graphRef) {
    deselectAllNodes();
    nodeGroups.filter(function (n) {
        return graphRef.getPartition(n.id) === selectionId;
    }).classed('selected', function (d) {
        d.previouslySelected = d.selected;
        return d.selected = true;
    });

    drawSelectedNodesHistogram();
}

const changeGroupColour = function(input, selectionId, graphRef) {
    const selectionPanel = input.parentNode;
    const newBackgroundColour = input.value;
    selectionPanel.style.backgroundColor = newBackgroundColour;
    const selectionNodes = node.filter(function (n) {
        return graphRef.getPartition(n.id) === selectionId;
    });

    selectionNodes.style("fill", function (d) {
        link.filter(function (l) { return l.source === d.id || l.source.id === d.id })
            .style("stroke", newBackgroundColour);
        return newBackgroundColour;
    });

}

//Set color of nodes for certain selection
const setGroupColour = function (d) {
    document.getElementById("selection_color_" + d.id).value = groupColours(d.id);
}

//Get color of nodes in certain selection
const getGroupColour = function (d) {
    return document.getElementById("selection_color_" + d.id).value;
}

const addNewSelection = function (newId = null) {
    const { length, [length - 1]: lastNode } = selectionGraph.nodes;
    if (newId === null) {
        newId = length === 0 ? 0 : lastNode.id + 1;
    }

    const newSelection = {};
    newSelection['id'] = newId;
    newSelection['name'] = 'Selection ' + newId;
    newSelection['nonodes'] = 0;

    selectionGraph.nodes.push(newSelection);

    for (const node of selectionGraph.nodes) {
        const newLink = {};
        newLink['source'] = newId;
        newLink['target'] = node.id;
        newLink['value'] = 0;

        const newLink2 = {};
        newLink2['source'] = node.id;
        newLink2['target'] = newId;
        newLink2['value'] = 0;

        selectionGraph.links.push(newLink);
        if (newId != node.id) {
            selectionGraph.links.push(newLink2);
        }
    }

    addSelectionDiv(newSelection);

}

//Add new custom's group div
const addSelectionDiv = function (selectionData) {
    const mainDiv = d3.select('#list-selections');
    const { id: selectionId } = selectionData;

    const panel = mainDiv
        .append('div')
        .datum(selectionData)
        .classed('selection-panel', true)
        .attr('id', `selection_panel_${selectionId}`)
        
        .on('click', `selectNodesBySelection(${selectionId}, ${currentGraph})`);

    panel.append('h4')
        .attr('class', 'panel-title')
        .attr('contenteditable', 'true')
        .attr('onclick', 'stopClickPropagation(event)')
        .html(`Selection \"${selectionId}\""`);

    /*panel.style('background-color', groupColours(selectionId));*/

    const panel_list_add_btn = panel.append('button')
        .attr('class', 'btn btn-danger btn-sm rounded-0')
        .attr('type', 'button')
        .attr('data-toggle', 'tooltip')
        .attr('data-placement', 'top')
        .attr('title', 'Add Selected Nodes To This Group')
        .attr('onclick', `addNodesToSelection(event, ${selectionId})`);

    panel_list_add_btn.append('i')
        .attr('class', 'fa fa-plus-square');

    const panel_list_delete_btn = panel.append('button')
        .attr('class', 'btn btn-danger btn-sm rounded-0')
        .attr('type', 'button')
        .attr('data-toggle', 'tooltip')
        .attr('data-placement', 'top')
        .attr('title', 'Delete')
        .attr('onclick', `deleteSelection(event, ${selectionId})`);

    panel_list_delete_btn.append('i')
        .attr('class', 'fa fa-trash');
}

const addSelectionDivs = function (selectionGraph) {
    const mainDiv = d3.select('#list-selections');

    const panels = mainDiv
        .selectAll("div")
        .data(selectionGraph.nodes)
        .enter()
        .append('div')
        .attr('class', 'selection-panel')
        .attr('id', (d) => { return `selection_panel_${d.id}`; })
        .on('click', function (d) { selectNodesBySelection(d.id, currentGraph); });

    panels.append('h4')
        .attr('class', 'panel-title')
        .attr('contenteditable', 'true')
        .on('click', () => { stopClickPropagation(d3.event); })
        .html((d) => { return `Selection \"${d.id}\"`; });

    const panel_list_add_btn = panels.append('button')
        .attr('class', 'btn btn-danger btn-sm rounded-0')
        .attr('type', 'button')
        .attr('data-toggle', 'tooltip')
        .attr('data-placement', 'top')
        .attr('title', 'Add Selected Nodes To This Group')
        .on('click', function (e, d) { addNodesToSelection(e, d.id); });

    panel_list_add_btn.append('i')
        .attr('class', 'fa fa-plus-square');

    const panel_list_delete_btn = panels.append('button')
        .attr('class', 'btn btn-danger btn-sm rounded-0')
        .attr('type', 'button')
        .attr('data-toggle', 'tooltip')
        .attr('data-placement', 'top')
        .attr('title', 'Delete')
        .on('click', function (e, d) { deleteSelection(e, d.id); });

    panel_list_delete_btn.append('i')
        .attr('class', 'fa fa-trash');

    const partitionColourList = d3.select("#partition-colour-list").html("");
}






//Move nodes to different selection
const addNodesToSelection = function (event, selectionId) {
    stopClickPropagation(event);
    const newColour = document.getElementById("selection_color_" + selectionId).value;
    const lightness = fontLightness(newColour);

    node.filter(function (d) { return d.selected })
        .each(function (d) {
            let previousGroup = null;
            const { id: nodeId } = d;
            const { [nodeId]: partition } = graph.partitions;

            if (partition != "") {
                previousGroup = partition;
                link.filter(function (l) { return l.source.id == nodeId || l.target.id == nodeId })
                    .each(function (l) {
                        const { source: { id: sourceId }, target: { id: targetId }, value } = l;
                        const { [sourceId]: node1Partition, [targetId]: node2Partition } = graph.partitions;

                        if (node1Partition != "" && node2Partition != "") {

                            if (sourceId == nodeId && node2Partition != "") {
                                //var previousSelectionLink = d3.select("#selection_link_" + previousGroup + "-" + node2Partition);
                                const newSelectionLink = selectionGraph.links.find(x => x.source.id == selectionId && x.target.id == node2Partition);
                                const previousSelectionLink = selectionGraph.links.find(x => x.source.id == previousGroup && x.target.id == node2Partition);
                                previousSelectionLink.value = previousSelectionLink.value - value;
                                newSelectionLink.value = previousSelectionLink.value + value;
                            }

                            else if (targetId == nodeId && node1Partition != "") {
                                const previousSelectionLink = selectionGraph.links.find(x => x.source.id == node1Partition && x.target.id == previousGroup);
                                const newSelectionLink = selectionGraph.links.find(x => x.source.id == node1Partition && x.target.id == selectionId);
                                previousSelectionLink.value = previousSelectionLink.value - value;
                                newSelectionLink.value = previousSelectionLink.value + value;
                            }
                        }
                    });

                const previousSelectionNode = selectionGraph.nodes.find(x => x.id == previousGroup);
                previousSelectionNode.nonodes = previousSelectionNode.nonodes - 1;

            }

            else {
                link.filter(function (l) { return l.source.id == nodeId || l.target.id == nodeId })
                    .each(function (l) {
                        const { source: { id: sourceId }, target: { id: targetId }, value } = l;
                        const { [sourceId]: node1Partition, [targetId]: node2Partition } = graph.partitions;

                        if (sourceId == nodeId && node2Partition != "") {
                            var newSelectionLink = selectionGraph.links.find(sl => sl.source.id == selectionId && sl.target.id == node2Partition);
                            newSelectionLink.value = newSelectionLink.value + value;
                        }

                        else if (targetId == nodeId && node1Partition != "") {
                            var newSelectionLink = selectionGraph.links.find(sl => sl.source.id == node1Partition && sl.target.id == selectionId);
                            newSelectionLink.value = newSelectionLink.value + value;
                        }

                    });



            }

            const newSelectionNode = selectionGraph.nodes.find(x => x.id == selectionId);
            newSelectionNode.nonodes = newSelectionNode.nonodes + 1;



            graph.partitions[d.id] = selectionId;


        })
        .style('fill', function (d) {
            const heading = document.getElementById('heading-' + d.id);

            heading.style.backgroundColor = newColour;
            heading.style.color = 'hsl(0, 0%, ' + String(lightness) + '%)';
            return newColour;
        })

    //updateSelectionNodesAndLinks();

    selectionNode.select("title")
        .text(function (d) {
            return "Number of Nodes: " + d.nonodes;
        })

    selectionLink.select("title")
        .text(function (d) {
            return d.value;
        })

}

//Deletes all selections
const deleteAllSelections = function () {
    currentGraph.clearPartitions();

    selectionGraph.nodes = [];
    selectionGraph.links = [];

    updateSelectionNodesAndLinks();

    document.getElementById('list-selections').innerHTML = "";
    document.getElementById("partition-colour-list").innerHTML = "";
    //document.getElementById("partition-metric-mcc-attribute-select").innerHTML = "";

    setDefaultNodeAndLinkColour(node, link);
}



//Deletes one specific selection
const deleteSelection = function (event, selectionId) {
    event.stopPropagation();
    const selectionPanel = document.getElementById('selection_panel_' + selectionId);
    selectionPanel.parentNode.removeChild(selectionPanel);

    const lightness = fontLightness(forceProperties.colouring.network);
    const nodesFromDeletedPartition = node.filter(function (d) { return graph.partitions[d.id] == selectionId; })

    if (!forceProperties.attributeColouring.enabled) {
        nodesFromDeletedPartition.style("fill", function (d) {
            link.filter(function (l) { return l.source.id === d.id; })
                .style("stroke", forceProperties.colouring.network);

            d3.select('#heading-' + d.id)
                .style("background-color", forceProperties.colouring.network)
                .style("color", 'hsl(0, 0%, ' + String(lightness) + '%)');
            graph.partitions[d.id] = "";
            return forceProperties.colouring.network;
        });
    }

    else {
        nodesFromDeletedPartition.each(function (d) {
            d3.select('#heading-' + d.id)
                .style("background-color", forceProperties.colouring.network)
                .style("color", 'hsl(0, 0%, ' + String(lightness) + '%)');
            graph.partitions[d.id] = "";
            return forceProperties.colouring.network;
        });
    }


    selectionGraph.nodes = selectionGraph.nodes.filter(function (n) { return n.id != selectionId });
    selectionGraph.links = selectionGraph.links.filter(function (d) { return d.source.id != selectionId && d.target.id != selectionId });


    updateSelectionNodesAndLinks();
    //updateSelectionForces()

}

const stringifyCommunityDetectionLinkReplacer = function (key, value) {
    switch (key) {
        case "source":
        case "target": {
            return value.id;
        }
            
        default: {
                return value;
        }
    }
}

const fillPartitionsWithAttribute = function (attributeName, currentGraphRef) {
    for (const node in currentGraphRef.nodes) {
        currentGraphRef.setPartition(node, currentGraphRef.getNodeDataValue(node, attributeName));
    }
}


const assignAttributePartitions = function (attributeSelect, currentGraphRef) {
    deleteAllSelections();
    const attributeName = document.getElementById(attributeSelect).value;
    if (attributeName === "modularity") {
        requestCommunityDetection();
        return;
    }

    const attributesDistinctValues = currentGraphRef.getDistinctValues(attributeName);
    fillPartitionsWithAttribute(attributeName, currentGraphRef);

    for (const value of attributesDistinctValues) {
        addNewSelection(value);
    }

    updateSelectionNodesAndLinks();
    //setDefaultNodeAndLinkColour(node, link);
}

//Request for community detection on server
const requestCommunityDetection = function () {
    //const graph_string = JSON.stringify(graph);
    const nodes_string = JSON.stringify(currentGraph.nodes, ["id"]);
    const links_string = JSON.stringify(currentGraph.links, stringifyCommunityDetectionLinkReplacer);
    
    $.ajax({
        url: /*'/mvne/Home/GraphCommunityDetection'*/ 'GraphCommunityDetection', 
        type: 'POST',
        dataType: 'json',
        // It is important to set the content type
        // request header to application/json because
        // that's how the client will send the request
        contentType: "application/x-www-form-urlencoded",
        data: {
            nodes: nodes_string,
            links: links_string
        },
        //cache: false,
        success: function (result) {
            deleteAllSelections();
            currentGraph.partitions = JSON.parse(result.newPartitions);
            selectionGraph = JSON.parse(result.newSelections);
            
            addSelectionDivs(selectionGraph);
            updatePartitionColours();
            updatePartitionColourList();
            updateSelectionNodesAndLinks();

            setPartitionColouring("partition-colour-list");
        },
        error: function (xhr, ajaxOptions, thrownError) {
            if (xhr.status === 401) {
                window.location.href = '/Login/Login';
            }
            alert(thrownError);
        }
    });

    return false;
}

const attributeTransform = {}
const excludedAttributes = [];
let currentRemodelSettings = {
    algorithm: "",
    algorithmParams: [],
    nulify: false,
    metric: "",
    metricParams: [],
    activeFeatures: [],
    inactiveFeatures: []
}

const updateRemodelOptionsHeader = function (headerId, attributeSelectId) {
    const header = document.getElementById(headerId);
    const attributeSelect = document.getElementById(attributeSelectId);
    header.innerHTML = attributeSelect.value + " remodeling options";
}

const displayAttributeTransformation = function (attribute, transformationListId) {
    d3.select("#" + transformationListId).html("");
    const { [attribute]: transformations } = attributeTransform;
    if (transformations) {
        for (const transformation of transformations) {
            const transformationName = transformation.charAt(0).toUpperCase() + transformation.slice(1);
            addTransformationElement(transformationListId, transformation, transformationName);
        }
    }
    //const remodelCheckbox = document.getElementById("remodel-checkbox");
    //const isIn = excludedAttributes.includes(attribute);
    //remodelCheckbox.checked = !isIn;
} 

const deleteAllTransformations = function () {
    attributeTransform = {};
    document.getElementById("attribute-transformation-list").innerHTML = "";
}
const clearAttributeTransformations = function (attributeSelectId) {
    document.getElementById("attribute-transformation-list").innerHTML = "";
    const attribute = document.getElementById(attributeSelectId).value;
    if (attributeTransform[attribute]) {
        delete attributeTransform[attribute];
    }
}

const deleteTransformation = function (deleteBtn) {
    const transformationItem = deleteBtn.parentElement;
    const selectedAttribute = document.getElementById("remodel-network-select").value;
    const transformationItemIndex = $(transformationItem).index();
    attributeTransform[selectedAttribute].splice(transformationItemIndex, 1);
    transformationItem.remove();
}

const transformationDragStart = function (e) {
    var index = $(e.currentTarget).index();
    e.dataTransfer.setData('text/plain', index);
}

const transformationDrop = function (e) {
    cancelDefaultBehaviour(e);
    const selectedAttribute = document.getElementById("remodel-network-select").value;
    this.classList.remove("transformation-dragover");
    // get new and old index
    const oldIndex = parseInt(e.dataTransfer.getData('text/plain'));
    const target = $(e.currentTarget);
    const newIndex = target.index();

    if (newIndex === oldIndex) {
        return;
    }

    const transformArray = attributeTransform[selectedAttribute];
    const temp = transformArray[newIndex];
    transformArray[newIndex] = transformArray[oldIndex];
    transformArray[oldIndex] = temp;

    // remove dropped items at old place
    let dropped = $(this).parent().children().eq(oldIndex).remove();

    // insert the dropped items at new place
    if (newIndex < oldIndex) {
        target.before(dropped);
    } else {
        target.after(dropped);
    }
}

const transformationDragOver = function (e) {
    cancelDefaultBehaviour(e);
    this.classList.add("transformation-dragover");
}

const transformationDragLeave = function (e) {
    cancelDefaultBehaviour(e);
    this.classList.remove("transformation-dragover");
}


const addToTransformationList = function (attribute, transformationType) {
    if (!(attribute in attributeTransform)) {
        attributeTransform[attribute] = [];
    }

    attributeTransform[attribute].push(transformationType);
}

const addTransformationElement = function (transformationListId, transformationType, transformationName) {
    const newTransformationListItem = d3.select("#" + transformationListId)
        .append("li")
        .classed("transformation-li", true)
        .attr("draggable", true)
        .attr("data-role", transformationType)

    newTransformationListItem.node().addEventListener("dragstart", transformationDragStart, true);
    newTransformationListItem.node().addEventListener("drop", transformationDrop, true);
    newTransformationListItem.node().addEventListener("dragover", transformationDragOver, true);
    newTransformationListItem.node().addEventListener("dragenter", cancelDefaultBehaviour, true);
    newTransformationListItem.node().addEventListener("dragleave", transformationDragLeave, true);


    newTransformationListItem
        .append("h5")
        .text(transformationName)

    newTransformationListItem
        .append("button")
        .text("Delete")
        .on("click", function () { deleteTransformation(this); })
}

const addTransformation = function (transformationBtn, attributeSelectId, transformationListId) {
    const transformationControlElement = transformationBtn.parentElement;
    const transformationName = transformationControlElement.firstElementChild.innerHTML;
    const transformationType = transformationControlElement.getAttribute("data-role");
    const attributeSelect = document.getElementById(attributeSelectId);
    const attribute = attributeSelect.value;

    if (attribute !== "" && attribute !== undefined) {
        addToTransformationList(attribute, transformationType);
        addTransformationElement(transformationListId, transformationType, transformationName);
    }
}

const addTransformationToAll = function (transformationBtn, attributeSelectId) {
    const transformationControlElement = transformationBtn.parentElement;
    const transformationName = transformationControlElement.firstElementChild.innerHTML;
    const transformationType = transformationControlElement.getAttribute("data-role");
    const attributeSelect = document.getElementById(attributeSelectId);
    const selectedAttribute = attributeSelect.value;

    if (selectedAttribute !== "" && selectedAttribute !== undefined) {
        for (let attribute of attributeSelect.options) {
            addToTransformationList(attribute.value, transformationType);
        }

        addTransformationElement("attribute-transformation-list", transformationType, transformationName);
    }
}

const transferSelectedOptions = function(fromSelectId, toSelectId){
    const fromSelectedOptions = $(`#${fromSelectId} option:selected`).remove();
    const toSelect = $(`#${toSelectId}`);

    toSelect.append(fromSelectedOptions);
}

const addNewAttributeControls = function (featureName) {
    const targetSelects = [
        { selector: "#project-x-attributes>optgroup[label=Attributes]" },
        { selector: "#project-y-attributes>optgroup[label=Attributes]" },
        { selector: "#remodel-active-attributes-select"},
        { selector: "#node-label-select>optgroup[label=Attributes]" },
        { selector: "#attribute-node-colouring>optgroup[label=Attributes]" },
        { selector: "#attribute-node-sizing>optgroup[label=Attributes]" }
    ];

    for (const { selector, title } of targetSelects) {
        const option = d3.create("option")
            .property("value", featureName)
            .attr("title", featureName)
            .html(featureName);

        d3.select(selector).append(() => option.node());
    }

    addNumericalFeatureDisplay(featureName);
}

const addNumericalFeatureDisplay = function (featureName) {
    const featureDiv = d3.select("#node-attributes-numerical");

    const nodeFeatureGroup = featureDiv.append("div");
    nodeFeatureGroup.append("label")
        .attr("title", featureName)
        .attr("for", `display-${featureName}`)
        .html(`${featureName}:`)

    nodeFeatureGroup.append("input")
        .attr("type", "text")
        .attr("id", `display-${featureName}`)
        .property("value", "")
        .attr("data-attribute", featureName)
        .attr("readonly", true);

    //Histogram
    const containerDivId = `${featureName}-histogram-container`;
    featureDiv.append("div")
        .attr("id", `${featureName}-histogram-container`);

    const featureValues = currentGraph.getAllAttributeValues(featureName);

    hist(containerDivId, featureValues, featureName, 300, 100);
        
}

const remodelNetwork = function (checkboxesDivId, algorithmSelectId, metricSelectId, nulifyId) {
    const selectedAlgorithm = document.getElementById(algorithmSelectId).value;
    const selectedMetric = document.getElementById(metricSelectId).value;
    const nulify = document.getElementById(nulifyId).checked;
    const excludedAttributes = $("#remodel-inactive-attributes-select option")
        .map(function ()
        {
            return $(this).val();
        }).get();

    const tempRemodelSettings = structuredClone(currentRemodelSettings);

    tempRemodelSettings.algorithm = selectedAlgorithm;
    tempRemodelSettings.metric = selectedMetric;
    tempRemodelSettings.nulify = nulify;

    const networkRemodelParams =
    {
        "metric": {
            "name": selectedMetric,
            "params": [],
            "nulify": nulify


        },
        "algorithm": {
            "name": selectedAlgorithm,
            "params": []
        }
    };

    switch (selectedMetric) {
        default:
            break;
        case 'GaussKernel':
            const metricParams = networkRemodelParams["metric"]["params"];
            const sigma = parseFloat(document.getElementById('remodel_sigma').value);
            metricParams.push(sigma);
            tempRemodelSettings.metricParams.push(sigma);
            break;
    }

    const selectedParametersDiv = selectedAlgorithm.toLowerCase() + "-parameters-remodel";
    const algorithmParametersDiv = document.getElementById(selectedParametersDiv);
    const parameterInputs = algorithmParametersDiv.querySelectorAll("input[type=number]");
    const algorithmParams = networkRemodelParams["algorithm"]["params"];
    for (const parameter of parameterInputs) {
        algorithmParams.push(parseFloat(parameter.value));
        tempRemodelSettings.algorithmParams.push(parameter.value);
    }

    tempRemodelSettings.activeFeatures = Array.from(d3.select("#remodel-active-attributes-select").property("options"), opt => opt.value);
    tempRemodelSettings.inactiveFeatures = Array.from(d3.select("#remodel-inactive-attributes-select").property("options"), opt => opt.value);

    const nodes_string = JSON.stringify(dataStore.nodeData);
    const attributes_string = JSON.stringify(currentGraph.attributes);
    const attribute_transform_string = JSON.stringify(attributeTransform);
    const network_remodel_params_string = JSON.stringify(networkRemodelParams);
    const excluded_attributes_string = JSON.stringify(excludedAttributes);

    $.ajax({
        url: 'RemodelNetwork',
        type: 'POST',
        
        data: {
            nodes: nodes_string,
            attributes: attributes_string,
            attributeTransform: attribute_transform_string,
            networkRemodelParams: network_remodel_params_string,
            excludedAttributes: excluded_attributes_string
        },
        success: function (result) {
            currentRemodelSettings = tempRemodelSettings;
            if (result.newVectorData != "") {
                const newVectorData = JSON.parse(result.newVectorData);
                dataStore.nodeData = newVectorData;

                const newTransformedColumnNames = JSON.parse(result.newTransformedColumnNames);
                currentGraph.attributes.num.push(...newTransformedColumnNames);
                for (const columnName of newTransformedColumnNames) {
                    addNewAttributeControls(columnName);
                }
            }
            const newNet = JSON.parse(result.newNetwork);
            currentGraph.links = newNet;
            currentGraph.updateLinkIndeces();

            currentGraph.similarityMatrix = JSON.parse(result.simMat);
            drawHeatmap(currentGraph.similarityMatrix);
            updateLinks();
            requestCommunityDetection(currentGraph);
            calculateAllMetrics();
            startSimulation();

        },
        error: function (xhr, ajaxOptions, thrownError) {
            if (xhr.status === 401) {
                window.location.href = '/Login/Login';
            }
            alert(thrownError);
        }
    });
}
//const { selectAll } = require("d3-selection");

const freedmanDiaconisRule = function (currentGraph, attribute) {
    let IQRValue = IQR(nodes, attribute);
    if (IQRValue === 0) {
        IQRValue = IQRValue + 1;
    }

    return Math.ceil(2 * IQRValue * Math.pow(nodes.length, (-1.0 / 3)));
}

const sigmaG1 = function (n){
    return Math.sqrt(((6.0 * (n - 2))) / ((n + 1) * (n + 3)));
}

const dormanFormula = function (attributeValues) {
    const nodeCount = attributeValues.length;
    const attributeSkewness = skewness(attributeValues);
    const attributeSigmaG1 = sigmaG1(nodeCount)
    const k = 1 + Math.log2(nodeCount) + Math.log2(1 + (Math.abs(attributeSkewness) / attributeSigmaG1));
    return k;
}

const hist = function (containerDivId, data, attribute, svgWidth, svgHeight) {
    const nBins = 30;//dormanFormula(attributeValues);
    const histogramMargin = { top: 10, right: 10, bottom: 20, left: 25 },
        histogramWidth = svgWidth - (histogramMargin.left + histogramMargin.right),
        histogramHeight = svgHeight - (histogramMargin.top + histogramMargin.bottom);


    const xMin = d3.min(data);
    let xMax = d3.max(data);
    xMax += xMax * 0.1;
    const xAxis = createLinearAxis(xMin, xMax, 0, histogramWidth).nice();
    


    const histogram = d3
        .histogram()
        .domain(xAxis.domain())
        .thresholds(xAxis.ticks(nBins));

    const bins = histogram(data);

    const yMin = 0;
    const yMax = d3.max(bins, function (d) {
        return d.length;
    });
    const yAxis = createLinearAxis(yMin, yMax, histogramHeight, 0)

    //const yAxis = createLogAxis(yMin, yMax, histogramHeight, 0, 2)
    

    const plotContainer = getPlotContainer(containerDivId);
    const histogramSvg =
        createHistogramGraphSvg(plotContainer, svgWidth,
            svgHeight, histogramMargin, attribute, `${attribute}-histogram`);

    
    appendGraphXAxis(histogramSvg, xAxis, 0, histogramHeight);
    appendGraphYLeftAxis(histogramSvg, yAxis, 0, 0, 8);
    appendHistogramBins(histogramSvg, bins, histogramHeight, xAxis, yAxis);
}



const appendHistogramBins = function (svg, bins, height, xAxis, yAxis) {
    svg
        .selectAll("rect")
        .data(bins)
        .enter()
        .append("rect")
        .attr("x", 1)
        .attr("data-max-value", function (d) {
            return d.x1;
        })
        .attr("transform", function (d) {
            return "translate(" + xAxis(d.x0) + "," + yAxis(d.length) + ")";
        })
        .attr("width", function (d) {
            return xAxis(d.x1) - xAxis(d.x0) - 1;
        })
        .attr("height", function (d) {

            return height - yAxis(d.length);
        })
        .style("fill", "#ffeead");

    return svg;
}



const barplot = function (containerDivId, data, yMin, yMax, svgWidth, svgHeight, barColour, id, title, titleColour, paddingInner = 0.1) {
    const barplotMargin = { top: 25, right: 10, bottom: 30, left: 25 },
        barplotWidth = svgWidth - (barplotMargin.left + barplotMargin.right),
        barplotHeight = svgHeight - (barplotMargin.top + barplotMargin.bottom);

    const xAxis = createBandAxis(data.map((d) => { return d.x }), 0, barplotWidth, paddingInner);
    const yAxis = createLinearAxis(yMin, yMax, barplotHeight, 0);

    const plotContainer = getPlotContainer(containerDivId);
    const barplotSvg = createGraphSvg(plotContainer, svgWidth, svgHeight, barplotMargin, id)

    const axisColour = "black";
    appendGraphXAxis(barplotSvg, xAxis, 0, barplotHeight, axisColour, true);
    appendGraphYLeftAxis(barplotSvg, yAxis, 0, 0, undefined, axisColour);
    appendLine(barplotSvg, 0, barplotWidth, yAxis(0), yAxis(0), axisColour);
    appendTitle(barplotSvg, title, barplotWidth, barplotMargin, 16, titleColour);
    const tooltip = createTooltip(plotContainer, id);
    const mouseenter = createBarplotTooltipMouseEnter(tooltip);
    const mousemove = createTooltipMousemove(tooltip);
    const mouseleave = createTooltipMouseleave(tooltip);
    createBars(barplotSvg, data, xAxis, yAxis, barplotHeight, barColour, mouseenter, mousemove, mouseleave);

}

const createBars = function (svg, data, xAxis, yAxis, height, fillColor,
    mouseenter = null, mousemove = null, mouseleave = null) {

    gBars = svg
        .selectAll("mybar")
        .data(data)
        .enter()
        .append("g");

    gBars
        .append("rect")
        .attr("x", (d) => { return xAxis(d.x); })
        .attr("y", (d) => { return yAxis(1); })
        .attr("width", xAxis.bandwidth())
        .attr("height", (d) => { return Math.abs(yAxis(1) - yAxis(-1)); })
        .attr("fill-opacity", 0)
        .attr("stroke-opacity", 0)
        .attr("stroke", "black")
        .on("mouseenter", mouseenter)
        .on("mousemove", mousemove)
        .on("mouseleave", mouseleave);

    gBars
        .append("rect")
        .attr("x", (d) => { return xAxis(d.x); })
        .attr("y", (d) => { return yAxis(Math.max(0, d.y)); })
        .attr("width", xAxis.bandwidth())
        .attr("height", (d) => { return Math.abs(yAxis(d.y) - yAxis(0)); })
        .attr("pointer-events", "none");

    if (typeof fillColor === 'object' && !Array.isArray(fillColor) && fillColor !== null) {
        gBars.attr("fill", (d) => { return fillColor[d.x]; });
        return svg;
    }
    else if (Array.isArray(fillColor)) {
        gBars.attr("fill", (d, i) => { return fillColor[i]; });
        return svg;
    }
    else if (typeof fillColor === "string") {
        gBars.attr("fill", fillColor);
        return svg;
    }
    gBars.attr("fill", "#ffeead");
    return svg;
}

const boxplot = function (plotContainer, data, svgWidth, svgHeight, idPrefix ,id, title, boxColour = "red") {
    const boxplotMargin = { top: 25, right: 40, bottom: 50, left: 40 },
        boxplotWidth = svgWidth - (boxplotMargin.left + boxplotMargin.right),
        boxplotHeight = svgHeight - (boxplotMargin.top + boxplotMargin.bottom);

    let yMin = d3.min(data, function (d) { return d.value.min; });
    let yMax = d3.max(data, function (d) { return d.value.max; });

    const attributeRangePortion = (yMax - yMin) * 0.05;

    yMin -= attributeRangePortion;
    yMax += attributeRangePortion;

    const xAxis = createBandAxis(data.map(d => d.key), 0, boxplotWidth, 0.1, 0.3);
    const yAxis = createLinearAxis(yMin, yMax, boxplotHeight, 0);

    const boxplotSvgId = `${idPrefix}-${id}`;

    const divId = `${idPrefix}-${id}-container`;
    const plotDiv = plotContainer
        .append("div")
        .attr("id", divId)
        .style("position", "relative");
    
    const tooltip = createTooltip(plotDiv, divId);
    const mouseenter = createBoxplotTooltipMouseEnter(tooltip);
    const mousemove = createTooltipMousemove(tooltip);
    const mouseleave = createBoxplotTooltipMouseleave(tooltip);

    const boxplotSvg = createGraphSvg(plotDiv, svgWidth, svgHeight, boxplotMargin, boxplotSvgId);

    boxplotSvg
        .datum({ 'id': id });

    const axisColour = "black";
    appendGraphXAxis(boxplotSvg, xAxis, 0, boxplotHeight, axisColour, false);
    appendGraphYLeftAxis(boxplotSvg, yAxis, 0, 0, undefined, axisColour);
    appendGraphYRightAxis(boxplotSvg, yAxis, boxplotWidth, 0, axisColour);


    const boxContainers = boxplotSvg.selectAll("boxesG")
        .data(data)
        .enter()
        .append("g")
        .on("mouseenter", mouseenter)
        .on("mousemove", mousemove)
        .on("mouseleave", mouseleave);

    //boxes
    appendBoxplotRects(boxContainers, xAxis,
        yAxis, boxColour, axisColour);
    //medianLine
    appendMedianBoxplotLine(boxContainers, "median", xAxis, yAxis, axisColour);
    //verticalLine
    appendVerticalBoxplotLines(boxContainers, xAxis, yAxis, axisColour);
    //MinLine
    appendMinBoxplotLine(boxContainers, xAxis, yAxis, axisColour);
    //MaxLine
    appendMaxBoxplotLine(boxContainers, xAxis, yAxis, axisColour);

    appendTitle(boxplotSvg, title, boxplotWidth, boxplotMargin, 16);

    return boxplotSvg;
}

const appendBoxplotRects = function (svg, xAxis, yAxis, fillColour, strokeColour) {
    svg
        .append("rect")
        .attr("x", function (d) {
            return xAxis(d.key);
        })
        .attr("y", function (d) {
            return yAxis(d.value.q3);
        })
        .attr("width", xAxis.bandwidth())
        .attr("height", function (d) {
            return (yAxis(d.value.q1) - yAxis(d.value.q3));
        })
        .style("fill", function (d) {
            return fillColour;
        })
        .style("stroke", strokeColour);
}

const updateBoxplotColour = function (boxplotContainer, colourObject) {
    const boxes = boxplotContainer.selectAll("rect");
    if (typeof colourObject === 'string' || colourObject instanceof String) {
        boxes.style("fill", function (d) {
            return colourObject;
        });
    }
    else if (Array.isArray(colourObject)) {
        boxes.style("fill", function (d, i) {
            return colourObject[i];
        });
    }
    else if (typeof colourObject === 'object' && colourObject !== null)
    {
        boxes.style("fill", function (d, i) {
            return colourObject[d.key];
        });
    }
        
}

const createTooltip = function (plotContainer, id) {
    return plotContainer
        .append("div")
        .attr("class", "plot-tooltip")
        .attr("id", `${id}-tooltip`);
}

const createBarplotTooltipMouseEnter = function (tooltip) {
    const mouseenter = function (d) {
        const { x, y } = d;
        d3.select(this).style("stroke-opacity", 1);
        tooltip
            .html("x: " + x + "<br>" + "y: " + y.toFixed(2))
            .style("opacity", 1);
    }
    return mouseenter;
}

const createTooltipMousemove = function (tooltip) {
    const mousemove = function (d) {
        tooltip
            .style("left", (event.offsetX + 3)/*(d3.mouse(this)[0]+ 20)*/ + "px")
            .style("top", event.offsetY/*(d3.mouse(this)[1] + 11)*/ + "px");
    }
    return mousemove;
}

const createTooltipMouseleave = function (tooltip) {
    const mouseleave = function (d) {
        d3.select(this).style("stroke-opacity", 0);
        tooltip
            .style("opacity", 0);
    }
    return mouseleave;
}

const createBoxplotTooltipMouseEnter = function (tooltip) {
    const mouseenter = function (d) {
        const { className, value } = d;
        d3.select(this).selectAll("*").style("stroke", "black");
        const text = `Median: ${d.value.median.toFixed(2)} <br> Q1: ${d.value.q1.toFixed(2)} <br> Q3: ${d.value.q3.toFixed(2)} <br> IQR: ${d.value.IQR.toFixed(2)} <br> min: ${d.value.min.toFixed(2)} <br> max: ${d.value.max.toFixed(2)}`;
        tooltip
            .html(text)
            .style("opacity", 1);
    }
    return mouseenter;
}

const createBoxplotTooltipMouseleave = function (tooltip) {
    const mouseleave = function (d) {
        d3.select(this).selectAll("*").style("stroke", "black"/*white*/);
        tooltip
            .style("opacity", 0);
    }
    return mouseleave;
}

const getPlotContainer = function (containerDivId) {
    return d3.select(`#${containerDivId}`).html("");
}

const createGraphSvg = function (plotContainer, width, height, margin/*, attribute*/, id) {
    
    const histogramSvg = plotContainer
        .append("svg")
        .attr("width", "100%"/*width + margin.left + margin.right*/)
        .attr("height", height + margin.top + margin.bottom)
        //.attr("data-attribute", attribute)
        .attr("id", `${id}-svg`)
        .attr("viewBox", [0, 0, width, height])
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    return histogramSvg;
}

const createHistogramGraphSvg = function (plotContainer, width, height, margin, attribute, id) {

    const histogramSvg = plotContainer
        .append("svg")
        .attr("width", "100%"/*width + margin.left + margin.right*/)
        .attr("height", height + margin.top + margin.bottom)
        .attr("data-attribute", attribute)
        .attr("id", `${id}-svg`)
        .attr("viewBox", [0, 0, width, height])
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    return histogramSvg;
}



const appendGraphXAxis = function (svg, axis, translateX, translateY, colour = "black", hideLabels = false) {

    const axisBot = d3.axisBottom(axis);
    if (hideLabels) {
        axisBot.tickFormat("");
        axisBot.tickSize(0);
    }

    else {
        const maxAxisTickNameLength = 8;
        axisBot.tickFormat(function (d) {
            return d.length > maxAxisTickNameLength ? d.slice(0, maxAxisTickNameLength) : d;
        });
    }
    

    const resultAxis = svg
        .append("g")
        .attr("transform", "translate(" + translateX + "," + translateY + ")")
        .call(axisBot);

    

    resultAxis.selectAll(".domain,.tick line")
        .attr("stroke", colour);

    resultAxis.selectAll(".tick text")
        .attr("fill", colour)

    resultAxis.selectAll(".tick")
        .append("title")
        .text(function (d) {
            return d;
        });

    

    return resultAxis;
}

const tiltAxisText = function (axisGElement) {
    axisGElement.selectAll("text")
        .attr("transform", "translate(-10, 0) rotate(-90)")
        .style("text-anchor", "end");

    return axisGElement;
}

const appendGraphYLeftAxis = function (svg, axis, translateX, translateY, ticks = 10, colour = "black") {
    const resultAxis = svg
        .append("g")
        .attr("transform", "translate(" + translateX + "," + translateY + ")")
        .call(d3.axisLeft(axis)/*.ticks(ticks)*/);

    resultAxis.selectAll(".domain,.tick line")
        .attr("stroke", colour);

    resultAxis.selectAll(".tick text")
        .attr("fill", colour);

    return resultAxis;
}

const appendGraphYRightAxis = function (svg, axis, translateX, translateY, colour = "black") {
    const resultAxis = svg
        .append("g")
        .attr("transform", "translate(" + translateX + "," + translateY + ")")
        .call(d3.axisRight(axis));

    resultAxis.selectAll(".domain,.tick line")
        .attr("stroke", colour);

    resultAxis.selectAll(".tick text")
        .attr("fill", colour);

    return resultAxis;
}

const appendLine = function(svg, x1, x2, y1, y2, colour = "black"){
    svg.append("g")
        .style("stroke", colour)
        .append("line")
            .attr("x1", x1)
            .attr("x2", x2)
            .attr("y1", y1)
            .attr("y2", y2);
}

const appendTitle = function (container, titleText, plotWidth, plotMargin, fontSize, colour = "white") {
    return container.append("text")
        .attr("x", (plotWidth / 2))
        .attr("y", 0 - (plotMargin.top / 2))
        .attr("text-anchor", "middle")
        .style("font-size", `${fontSize}px`)
        .style("text-decoration", "underline")
        .style("fill", colour)
        .text(titleText);
}

const appendMedianBoxplotLine = function (svg, attributeName, xAxis, yAxis, colour = "black") {
    return svg
        .append("line")
        .attr("x1", function (d) { return xAxis(d.key); })
        .attr("x2", function (d) { return xAxis(d.key) + (xAxis.bandwidth()); })
        .attr("y1", function (d) { return yAxis(d.value[attributeName]); })
        .attr("y2", function (d) { return yAxis(d.value[attributeName]); })
        .style("stroke", colour)
}

const appendMinBoxplotLine = function (svg, xAxis, yAxis, colour = "black") {
    return svg
        .append("line")
        .attr("x1", function (d) { return xAxis(d.key) + (xAxis.bandwidth() / 3); })
        .attr("x2", function (d) { return (xAxis(d.key) + xAxis.bandwidth()) - (xAxis.bandwidth() / 3); })
        .attr("y1", function (d) { return yAxis(d.value.min); })
        .attr("y2", function (d) { return yAxis(d.value.min); })
        .style("stroke", colour);
        
}

const appendMaxBoxplotLine = function (svg, xAxis, yAxis, colour = "black") {
    return svg
        .append("line")
        .attr("x1", function (d) { return xAxis(d.key) + (xAxis.bandwidth() / 3); })
        .attr("x2", function (d) { return (xAxis(d.key) + xAxis.bandwidth()) - (xAxis.bandwidth() / 3); })
        .attr("y1", function (d) { return yAxis(d.value.max); })
        .attr("y2", function (d) { return yAxis(d.value.max); })
        .style("stroke", colour);
        
}

const appendVerticalBoxplotLines = function (svg, xAxis, yAxis, colour = "black") {
    return svg
        .append("line")
        .attr("x1", function (d) {
            return xAxis(d.key) + (xAxis.bandwidth() / 2);
        })
        .attr("x2", function (d) {
            return xAxis(d.key) + (xAxis.bandwidth() / 2);
        })
        .attr("y1", function (d) {
            return yAxis(d.value.max);
        })
        .attr("y2", function (d) {
            return yAxis(d.value.min);
        })
        .style("stroke", colour);
}




const createLinearAxis = function (domainMin, domainMax, rangeMin, rangeMax) {
    const axis = d3
        .scaleLinear()
        .domain([domainMin, domainMax])
        .range([rangeMin, rangeMax]);
    return axis;
}

const createBandAxis = function (domainValues, rangeMin, rangeMax, paddingInner = 0.1, paddingOuter = 0.5) {
    const axis = d3
        .scaleBand()
        .range([rangeMin, rangeMax])
        .domain(domainValues)
        .paddingInner(paddingInner)
        .paddingOuter(paddingOuter);
    return axis;
}

const createLogAxis = function (domainMin, domainMax, rangeMin, rangeMax, base = 10) {
    const axis = d3
        .scaleSymlog()
        .domain([domainMin, domainMax])
        .range([rangeMin, rangeMax])
        .constant(10)
        
    return axis;
}
const Q1 = function (attributeValueList) {
    const attributeValueListCount = attributeValueList.length;
    const Q1Index = Math.floor(attributeValueListCount / 4.0);
    if (Q1Index % 2 == 0) {
        const Q1Index2 = Q1Index - 1;
        const Q1 = (attributeValueList[Q1Index] + attributeValueList[Q1Index2]) / 2.0;
        return Q1;
    }

    const Q1 = attributeValueList[Q1Index];
    return Q1;
}

const Q3 = function (attributeValueList) {
    const attributeValueListCount = attributeValueList.length;
    const Q3Index = Math.floor(attributeValueListCount * (3.0 / 4.0));
    if (Q3Index % 2 == 0) {
        const Q3Index2 = Q3Index - 1;
        const Q3 = (attributeValueList[Q3Index] + attributeValueList[Q3Index2]) / 2.0;
        return Q3;
    }
    const Q3 = attributeValueList[Q3Index];

    return Q3;
}


const IQR = function (currentGraph, attribute) {
    const attributeValueList = getAttributeValueList(nodes, attribute);
    if (attributeValueList.length <= 2) {
        return -1;
    }
    attributeValueList.sort();

    return Q3(attributeValueList) - Q1(attributeValueList);
}

const mean = function (attributeValues) {
    let result = 0;
    for (const value of attributeValues) {
        result += value;
    }
    result /= attributeValues.length;
    return result;
}

const standardDeviation = function (attributeValues, iMean = null) {
    let result = 0;
    
    let attributeMean = iMean === null ? mean(attributeValues) : iMean;
    for (const value of attributeValues) {
        const difference = value - attributeMean;
        result += Math.pow(difference, 2);
    }

    result /= (attributeValues.length - 1);
    return result;
}

const skewness = function (attributeValues) {
    let result = 0;
    const attributeMean = mean(attributeValues);
    const attributeStd = standardDeviation(attributeValues, attributeMean);

    for (const value of attributeValues) {
        const difference = value - attributeMean;
        result += Math.pow(difference, 3);
    }
    result /= ((attributeValues.length - 1) * Math.pow(attributeStd, 3));
    return result;
}

class DataStore {
    constructor(data) {
        this._nodeData = data.nodes;
        this._linkData = data.links;
    }

    get nodeData() {
        return this._nodeData;
    }

    set nodeData(value) {
        this._nodeData = value;
    }

    get linkData() {
        return this._linkData;
    }

    getAllNodeData(id) {
        return this.nodeData[id];
    }

    getNodeDataValue(id, attribute) {
        return this._nodeData[id][attribute];
    }

    getLinkDataValue(id, attribute) {
        return this._linkData[id][attribute];
    }

    addNewNodeAttribute(id, attribute, value) {
        this._nodeData[id][attribute] = value;
    }

    removeNodeAttribute(id, attribute) {
        delete this._nodeData[id][attribute];
    }

    addNewLinkAttribute(id, attribute, value) {
        this._linkData[id][attribute] = value;
    }

    removeLinkAttribute(id, attribute) {
        delete this._linkData[id][attribute];
    }

    serialize() {
        const serializedData = {
            "nodeData": this._nodeData,
            "linkData": this._linkData
        };

        return serializedData;
    }

    deserialize(json) {
        this._nodeData = json.nodeData;
        this._linkData = json.linkData;
    }
}
//*****Display Metric******
const displayPartitionMetric = function () {
    const metric = document.getElementById("partition-metric-select").value;

    $("#partition-metrics>.partition-metric-wrapper").removeClass("active-block");
    document.getElementById(`partition-metric-${metric}-container`).classList.add("active-block");
}

//*******Silhouette barplots**********
const requestSilhouette = function () {
    //const graph_string = JSON.stringify(graph);
    const excludedAttributes = $("#remodel-inactive-attributes-select option")
        .map(function () {
            return $(this).val();
        }).get();


    const nodes_string = JSON.stringify(dataStore.nodeData);
    const attributes_string = JSON.stringify(currentGraph.attributes);
    const partitions_string = JSON.stringify(currentGraph.partitions);
    const excluded_attributes_string = JSON.stringify(excludedAttributes);
    const metric_string = JSON.stringify(currentGraph.metric);

    $.ajax({
        url: 'GetSilhouette',
        type: 'POST',
        dataType: 'json',
        // It is important to set the content type
        // request header to application/json because
        // that's how the client will send the request
        contentType: "application/x-www-form-urlencoded",
        data: {
            nodes: nodes_string,
            attributes: attributes_string,
            partitions: partitions_string,
            excludedAttributes: excluded_attributes_string,
            metric: metric_string
        },
        //cache: false,
        success: function (result) {
            const silhouetteData = JSON.parse(result.silhouetteData);
            const clusterDivs = d3.selectAll("#list-selections div");
            if (clusterDivs.size() > 0) {
                silhouetteData.sort((a, b) => { return b.y - a.y });
                const silhouetteDataGroupedByPartition = {};
                const clusterColours = {}
                clusterDivs.each(function (d) {
                    const { id } = d;
                    silhouetteDataGroupedByPartition[id] = [];
                    clusterColours[id] = d3.select(this).style("background-color");
                });

                const nodeColoursByPartition = {};

                for (const node of silhouetteData) {
                    const { x: nodeId } = node;
                    const nodePartition = currentGraph.getPartition(node.x);
                    silhouetteDataGroupedByPartition[nodePartition].push(node);
                    nodeColoursByPartition[nodeId] = clusterColours[nodePartition];
                }

                

                const clusterMetricContainer = d3.select("#partition-metric-silhouette-graph-container").html("");

                clusterDivs
                    .each(function (d) {
                        const clusterMetricDiv = clusterMetricContainer.append("div");
                        //addMccTable(clusterMetricDiv, d.id, mccObject);
                        const titleColour = d3.select(this).style("background-color");
                        const { id: clusterId } = d;
                        addSilhouettePlot(clusterMetricDiv, clusterId, silhouetteDataGroupedByPartition[clusterId], titleColour, titleColour);
                    });

                const silhouetteDataSorted = Object.values(silhouetteDataGroupedByPartition).flat(1);
                const clusterMetricWholeContainer = d3.select("#partition-metric-silhouette-complete-graph-container").html("");
                addSilhouettePlot(clusterMetricWholeContainer, "Complete", silhouetteDataSorted, nodeColoursByPartition, "white");

            }
        },
        error: function (xhr, ajaxOptions, thrownError) {
            console.log(xhr);
            console.log(ajaxOptions);
            console.log(thrownError);
            return Object.create(null);
        }
    });
}

const addSilhouettePlot = function (clusterMetricDiv, selectionId, data, barColour, titleColour) {
    const silhouetteID = `barplot-silhouette-${selectionId}`;
    clusterMetricDiv.append("div")
        .attr("id", silhouetteID)
        .style("position", "relative");
    barplot(silhouetteID, data, -1, 1, 300, 150, barColour, `barplot-silhouette-${selectionId}`, `\"${selectionId} Silhouette\"`, titleColour, 0);
}

//********Partition MCC barplots********
const createPartitionMccGraphs = function () {
    const classAttribute = document.getElementById("partition-metric-mcc-attribute-select").value;
    currentGraph.classLabel = classAttribute;
    const mccObject = matthewsCorrelationCoeficient(classAttribute);
    const clusterMetricContainer = d3.select("#partition-metric-mcc-graph-container").html("");
    const clusterDivs = d3.selectAll("#list-selections div");
    if (clusterDivs.size() > 0) {
        clusterDivs
            .each(function (d) {
                const clusterMetricDiv = clusterMetricContainer.append("div");
                //addMccTable(clusterMetricDiv, d.id, mccObject);
                const titleColour = d3.select(this).style("background-color");
                addMccPlot(clusterMetricDiv, d.id, mccObject, titleColour);
            });

        /*const distinctClasses = currentGraph.getDistinctValues(classAttribute);*/
        //const classColourList = d3.select("#class-colour-list").html("");
        //for (const realClass of distinctClasses) {
        //    addListColour(realClass, groupColours(realClass), "class", classColourList);
        //}
        //changeClassColouringFromSettings('partition-metric-mcc-attribute-select', 'class-colour-list', false);
    }


}

const addMccTable = function (clusterMetricDiv, selectionId, mccObject) {
    const mccTableDiv = clusterMetricDiv
        .append("div")
        .attr("class", "col-2-table");

    for (const mccPair of mccObject[selectionId]) {
        const { className, value } = mccPair;
        mccTableDiv.append("span")
            .text(className + ": " + value.toFixed(2))
            .style("border", "0.1rem solid white")
    }
}

const addMccPlot = function (clusterMetricDiv, selectionId, mccObject, titleColour) {
    const barplotID = `barplot-mcc-${selectionId}`;
    clusterMetricDiv.append("div")
        .attr("id", barplotID)
        .style("position", "relative");
    barplot(barplotID, mccObject[selectionId], -1, 1, 300, 150, null,`barplot-mcc-${selectionId}`, `Cluster ${selectionId} MCC`, titleColour);
}

const matthewsCorrelationCoeficient = function (classAttributeName) {
    const distinctPartitions = currentGraph.getDistinctPartitions();
    const distinctClasses = currentGraph.getDistinctValues(classAttributeName);

    if (!distinctClasses || !distinctPartitions) {
        return null;
    }


    const confusionMatrices = {};
    for (const partition of distinctPartitions) {
        confusionMatrices[partition] = {};
        const partitionObject = confusionMatrices[partition];
        for (const className of distinctClasses) {
            partitionObject[className] = {
                TP: 0,
                FN: 0,
                TN: 0,
                FP: 0
            };
        }
    }

    for (const [node, nodePartition] of Object.entries(currentGraph.partitions)) {
        const nodeRealClass = currentGraph.getNodeDataValue(node, classAttributeName);

        for (const partition in confusionMatrices) {
            if (partition === nodePartition) {
                for (const className in confusionMatrices[partition]) {
                    if (className === nodeRealClass) {
                        confusionMatrices[partition][className].TP += 1;
                        continue;
                    }
                    confusionMatrices[partition][className].FP += 1;
                }
                continue;
            }

            for (const className in confusionMatrices[partition]) {
                if (className === nodeRealClass) {
                    confusionMatrices[partition][className].FN += 1;
                    continue;
                }
                confusionMatrices[partition][className].TN += 1;
            }

        }
    }

    const mccObject = {};
    for (const partition of distinctPartitions) {
        mccObject[partition] = [];
        const partitionArray = mccObject[partition];
        for (const className of distinctClasses) {
            const { TP, FP, FN, TN } = confusionMatrices[partition][className];

            const mccNumerator = (TN * TP) - (FN * FP);
            const mccDenominator = Math.sqrt((TP + FP) * (TP + FN) * (TN + FP) * (TN + FN));
            const mcc = mccNumerator / mccDenominator;
            partitionArray.push({ "x": className, "y": mcc });
        }
    }


    return mccObject;

}
//*******Partition attribute boxplots********

const generateAttributeAcrossPartitionsBoxplots = function () {
    const partitionMetricContainer = d3.select("#partition-metric-attribute-boxplot-graph-container").html("");
    const clusterDivs = d3.selectAll("#list-selections div");

    if (clusterDivs.size() > 0) {
        let activeAttributes = [];
        d3.selectAll("#remodel-active-attributes-select option").each(function (d) {
            activeAttributes.push(d3.select(this).property("value"));
        });

        for (const attribute of activeAttributes) {
            const partitionStats = d3.nest()
                .key(function (d) { return currentGraph.getPartition(d.id) })
                .rollup(function (d) {
                    q1 = d3.quantile(d.map(function (g) {
                        return currentGraph.getNodeDataValue(g.id, attribute);
                    }).sort(d3.ascending), .25);
                    median = d3.quantile(d.map(function (g) { return currentGraph.getNodeDataValue(g.id, attribute); }).sort(d3.ascending), .5);
                    q3 = d3.quantile(d.map(function (g) { return currentGraph.getNodeDataValue(g.id, attribute); }).sort(d3.ascending), .75);
                    IQRValue = q3 - q1;
                    min = d3.min(d.map(function (g) { return currentGraph.getNodeDataValue(g.id, attribute); }));
                    max = d3.max(d.map(function (g) { return currentGraph.getNodeDataValue(g.id, attribute); }));
                    return ({ q1: q1, median: median, q3: q3, "IQR": IQRValue, min: min, max: max });
                })
                .entries(currentGraph.nodes);

            partitionStats.sort(function (a, b) {
                return ('' + a.key).localeCompare(b.key);
            });
            boxplot(partitionMetricContainer, partitionStats, 600, 400, 'partition-metric-attribute-boxplot', attribute, `${attribute} boxplot`);
        }

        const colourObject = contructColourObjectFromList("partition-colour-list");
        updateBoxplotColour(partitionMetricContainer, colourObject);
    }
}

const generatePartitionAcrossAttributesBoxplots = function () {
    const partitionMetricContainer = d3.select("#partition-metric-partition-boxplot-graph-container").html("");
    const clusterDivs = d3.selectAll("#list-selections div");

    if (clusterDivs.size() > 0) {
        let activeAttributes = [];
        d3.selectAll("#remodel-active-attributes-select option").each(function (d) {
            activeAttributes.push(d3.select(this).property("value"));
        });
        clusterDivs.each(function (p) {
            const partition = p.id;
            const partitionNodes = currentGraph.nodes.filter(d => { return currentGraph.getPartition(d.id) === partition; });
            const partitionStats = d3.nest()
                .key(function (attr) { return attr; })
                .rollup(function (attr) {
                    q1 = d3.quantile(partitionNodes.map(function (g) {
                        return currentGraph.getNodeDataValue(g.id, attr);
                    }).sort(d3.ascending), .25);
                    median = d3.quantile(partitionNodes.map((g) => { return currentGraph.getNodeDataValue(g.id, attr); }).sort(d3.ascending), .5);
                    q3 = d3.quantile(partitionNodes.map((g) => { return currentGraph.getNodeDataValue(g.id, attr); }).sort(d3.ascending), .75);
                    IQRValue = q3 - q1;
                    min = d3.min(partitionNodes.map((g) => { return currentGraph.getNodeDataValue(g.id, attr); }));
                    max = d3.max(partitionNodes.map((g) => { return currentGraph.getNodeDataValue(g.id, attr); }));
                    return ({ q1: q1, median: median, q3: q3, "IQR": IQRValue, min: min, max: max });
                })
                .entries(activeAttributes);
            
            partitionStats.sort(function (a, b) {
                return ('' + a.key).localeCompare(b.key);
            });

            const colour = document.getElementById(`partition-colour-${partition}`).value;
            const boxplotSvg = boxplot(partitionMetricContainer, partitionStats, 600, 400,
                'partition-metric-partition-boxplot', partition, `Cluster ${partition} boxplot`, colour);
        });
    }


}

const changeBoxplotContainer = function (event) {
    $(".partition-boxplot-container").removeClass("active-grid")
    const boxplotGenerationType = {
        "attributes": function () {
            document.getElementById("partition-metric-partition-boxplot-graph-container").classList.add("active-grid");
        },
        "partitions": function () {
            document.getElementById("partition-metric-attribute-boxplot-graph-container").classList.add("active-grid");
        }
    }
    boxplotGenerationType[event.currentTarget.value]();
}

const invokeBoxplotGeneration = function () {
    const boxplotGenerationType = {
        "attributes": function () {
            generatePartitionAcrossAttributesBoxplots();
        },
        "partitions": function () {
            generateAttributeAcrossPartitionsBoxplots();
        }
    }
    const chosenBoxplotType = document.getElementById("partition-metric-boxplot-type-select").value;
    boxplotGenerationType[chosenBoxplotType]();
}
    
